---
layout: post
title:  "时序约束之时序分析与约束"
date:   2019-9-21 9:53:10 +0700
tags:
  - Digital IC Design
  - Tcl
---

----

### 1 前言

&#160; &#160; &#160; &#160; 时序分析分为：

* 动态时序分析；
* 静待时序分析（STA）。

> 动态时序分析是指在输入端输入一组向量，并观察信号到达电路中各个点的时间。

> 静态时序分析通过分析电路拓扑来计算相同的信息，而不需要任何输入向量。

&#160; &#160; &#160; &#160; 通常，时序分析指的是静态时序分析。

----

### 2 静态时序分析

> STA不依赖于输入向量，STA的内容包括分析电路拓扑并计算电路中不同信号到达各个点的时间窗口（time window），然后将其与要求信号到达该点的时间进行比较。只要信号到达的时间范围满足要求，从STA的角度看设计就是可用的。

&#160; &#160; &#160; &#160; 举例说明。如下抽象电路图：

![1](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BA%A6%E6%9D%9F/1.jpg)

&#160; &#160; &#160; &#160; STA知道信号到达输入in1和in2的时间，然后会计算这些信号到达输出out1的时间。同时STA还知道要求信号到达输出out1的时间。通过对比信号到达out1的时间和要求时间，STA工具将报告时序是否满足要求。如果电路中包括一些触发器，STA也会计算每个触发器接收时钟和数据的时间，然后对每个触发器上数据和时钟的到达时间与该触发器要求的建立和保持时间进行比较，如果不满足要求，STA工具会报告违规。

&#160; &#160; &#160; &#160; 再具体一点，如下电路图：

![2](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BA%A6%E6%9D%9F/2.jpg)

&#160; &#160; &#160; &#160; 在F1时钟得到每个有效边沿，其数据应该在F1建立窗口开始之前到达。只有在可靠捕获前一个数据之后，数据才能到达，而不能违反保持时间。这取决于触发边沿到达F1的时间、组合电路C1的延迟以及输入in1的到达时间。

&#160; &#160; &#160; &#160; F2也类似，时序要求将取决于触发边沿到达F2时钟引脚的时间、组合电路C2的延迟以及数据从F1开始的时间，**而这反过来又依赖与F1时钟引脚的触发边沿。**

----

### 3 时序约束在STA中的作用

> STA工具从相应的设计描述中获取电路描述，HDL是最常用的形式。他还接受库输入——主要用来了解所依赖技术的特性，如通过特定门的延迟值。

> STA工具需要的另一组输入与输入端各种信号的到达时间和其他特性以及各种输出的时间要求有关。这些输入通过时序约束来提供。

#### 3.1 作为声明

&#160; &#160; &#160; &#160; 某些约束只是工具的声明，不需要验证声明的准确性，仅将其用作自身的输入，以便验证时序是否满足。

&#160; &#160; &#160; &#160; 举例说明：

* 输入达到边界的时间；
* 输入的过渡时间（trnsition time，信号的状态翻转所需时间）；
* 输出必须驱动的负载。

#### 3.2 作为断言

&#160; &#160; &#160; &#160; 一些约束充当断言，STA工具需要验证设计符合这些约束。在进行各种计算之后，如果发现时序满足这些约束，则STA通过。

&#160; &#160; &#160; &#160; 举例说明：

* 输出在边界处可用的时间。

#### 3.3 作为指令

&#160; &#160; &#160; &#160; 约束可作为工具的指令。这种情况适用于实现工具，如综合或布局布线。这些实现工具将这些约束作为它们试图满足的目标。

#### 3.4 作为异常

&#160; &#160; &#160; &#160; 有一些约束做相反的事情，即他们指定约束放宽的范围。假设一些路径被约束以满足某些时序，但是由于某些特殊原因，这些路径并不需要满足这些时序。或者说，即使要求更宽松，它们也可以很好地工作。

#### 3.5 角色变化

&#160; &#160; &#160; &#160; 有时，同一个约束的角色也会发生变化。在设计的一个阶段，他可能是一个声明，而在另一个阶段，它可能变成一条指令。

----

### 4 STA中常见的问题

#### 4.1 无功能检查

&#160; &#160; &#160; &#160; STA只是时序分析，不包括（或验证）任何其他问题，它根本不进行功能检查。STA也不能保证电路能提供所需的功能，只意味着电路将以指定的频率工作。需要使用仿真、基于检查的断言、FPGA原型等一些技术来确保功能的正确性。

#### 4.2 无声明检查

&#160; &#160; &#160; &#160; STA工具不会质疑代表设计师意图的声明，简单地假设这些约束是真实的。

#### 4.3 要求正确

&#160; &#160; &#160; &#160; 约束必须处理好要求的约束与定义的约束之间的平衡。约束的理想使用应该既不过严也不过送。在拿不准的情况下，必须严一点。

#### 4.4 约束中常见错误

&#160; &#160; &#160; &#160; 以下是编写约束时可能会犯的一些最常见的错误：

* 不正常的时序异常：时序异常是最容易被误解的约束形式。通过指定这些异常，有时用户放宽了路径约束，但却不应该这样做；
* 不正确的时钟：这个错误可能存在于时钟周期或波形中。但更常见的问题通常与时钟产生有关。大部分用户仅将注意力集中在分频、倍频系数上，但如果没有仔细指定，所产生的的时钟波形的正负边沿可能会弄反；
* 与RTL的变化不同步：当设计多次重构或重复使用时，RTL得到了更新。但是，相应的约束不会更新。但是，通常情况下，这是因为用户不容易看到RTL的更改与约束中需要的更改的相关性。

#### 4.5 优秀的约束的特征

&#160; &#160; &#160; &#160; 对于任何给定的时序要求，可能有许多种应用约束的方法。一套优秀的约束应满足以下条件：

* 这些约束必须明显正确；
* 通过观察约束，可以清楚地理解意图，这有助于检查和找出错误，并且还能使约束不受设计中细微变化的影响；
* 对于异常情况，写约束时应特别小心，从而使RTL可能出现的细微变化不会导致异常失效；
* 约束应以能最容易迁移到新技术中的方式来编写；
* 约束应以简明扼要的方式来编写。


----

### 5 延迟计算与STA

&#160; &#160; &#160; &#160; 延迟计算和STA是两个截然不同的事情。STA严重依赖于延迟计算，延迟计算也有除了STA以外的其他应用。

&#160; &#160; &#160; &#160; 延迟计算执行以下活动：
* 计算通过特定的门、网络、网段、路径等的延迟；
* 计算特定门输出的压摆率；
* 当信号通过导线（它反过来又变为下一个门输入的压摆率）时，计算压摆率退化。

&#160; &#160; &#160; &#160; 之后，延迟值可能被STA工具直接用于时序分析。STA工具的功能可以总结为：

* 收集所有声明类型的约束，如什么时候输入可用；
* 将一些声明类型的约束传给延迟计算器，如输入过渡时间；
* 查看电路拓扑以识别各种时序路径；
* 从延迟计算器中获取路径延迟；
* 结合第一点和第四点来计算信号到达期望点的时间；
* 将信号到达时间与断言型约束进行比较，该约束可以告知信号何时可用；
* 根据实际到达时间和要求时间提供结果。

&#160; &#160; &#160; &#160; 显然，在很大程度上STA的正确性取决于潜在的延迟计算。

----

### 6 时序路径

&#160; &#160; &#160; &#160; 时序路径是指信号可以直接穿过，不必等待其他触发条件的路径。沿着时序路径，信号仅在通过电路元器件时有延迟。

#### 6.1 起点和终点

&#160; &#160; &#160; &#160; 信号时序开始的点称为起点。对于给定电路，所有输入都可以作为起点。信号必须被定时的点称为终点。因此，所有输出都可以作为终点。

&#160; &#160; &#160; &#160; 在寄存器中，输入D必须等待时钟触发的代打，所以直到D到达才能完成的过渡过程现在必须等待。进一步传递信号的时序将取决于时钟的到达时间。此处的D应检查是否满足建立和保持时间要求。因此时序路径在此结束，所以寄存器也可以做为终点。

&#160; &#160; &#160; &#160; 类似的，寄存器也可作为起点。信号将从寄存器的Q引脚开始，然后向前传递。严格来说，时序从时钟源开始，然后到达触发器的clock引脚，接着进入触发器的Q引脚，然后继续向前。所以严格来讲寄存器并不是真正的起点，但在绝大多数实际使用中，把寄存器称为起点。在实际分析中，对于以下电路，路径跟踪是从时钟源开始的：

![3](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BA%A6%E6%9D%9F/3.jpg)


&#160; &#160; &#160; &#160; 起点是：

* 原始输入（in1、clk、clr、in2）；
* 寄存器（F1、F2、F3、F4）——实际上是这些寄存器的时钟源。

&#160; &#160; &#160; &#160; 终点是：

* 原始输出（out1、out2、out3）——此处必须检查在要求的时间内信号在这些点可用；
* 寄存器（F1、F2、F3、F4）——此处必须检查D（和其他同步输入）输入满足建立和保持时间的要求。

&#160; &#160; &#160; &#160; 例如触发器F3，到达触发器的异步clear引脚的信号在此处不需要等待任何其他的触发。它可以简单的通过触发器的Q引脚直接向前。因此时序路径不需要在这里结束。所以当触发器的D引脚作为终点时，异步clear或set引脚可能不是终点。

#### 6.2 打断路径

&#160; &#160; &#160; &#160; 用户可以通过指定的一些启动条件或检查条件在设计的任何位置插入额外的起点和终点。通过指定起点或检查点，路径在该点被打断。

&#160; &#160; &#160; &#160; 例如在上图中，假设指定了从N1到N2的最大延迟为某个值，在这种情况下，必须在N2处进行检查。因此N2成了一个额外的终点，而且它也成为了下一段路径，即N2到out3的起点。类似的，由于信号跟踪从N1开始，所以它变成了起点，而且他也成为了前一段路径in2到N1的终点。

&#160; &#160; &#160; &#160; 如果指定in2到N1的延迟，则N1将成为终点，也将成为下一段路径的起点。但in2只是一个起点，他不会变为终点，因为在他之前没有路径。

&#160; &#160; &#160; &#160; 所以对于触发器F3，时序路径为clr->F3的clear引脚->F3的Q引脚->C3->F4的D引脚。

#### 6.3 功能路径与时序路径

&#160; &#160; &#160; &#160; 从起点直到终点的过渡过程的路径拓扑称为时序路径，他与功能路径不同，功能路径指的是信号流动的拓扑。

&#160; &#160; &#160; &#160; 例如上图从in1开始的信号穿过C1，然后到达F1的D引脚，之后，当时钟触发时，它将穿过F1到达C2并一直向前，所以这是一条功能路径。

&#160; &#160; &#160; &#160; 但这不是时序路径，因为无论信号何时到达D，都不知道它何时会继续通过该触发器，这取决于时钟触发何时到达该触发器。时序路径意味着当信号到达时，可以知道路径中下一个过渡过程将会发生的时间。

&#160; &#160; &#160; &#160; 不过实际的过渡过程可能发生也可能不发生。

&#160; &#160; &#160; &#160; 因此，时序路径指示过渡过程将会发生的顺序，而不必等待任何其他事情的发生。功能路径表示值将发生变化的顺序，值变化的时序可能仍然受其他事物的控制。

&#160; &#160; &#160; &#160; 有时，时序路径和功能路径可能重叠。


#### 6.4 时钟路径与数据路径

&#160; &#160; &#160; &#160; 流入触发器数据引脚的路径称为数据路径，所以数据路径可以是：

* 从一个触发器的输出到另一个触发器的数据输入；
* 从原始端口到触发器的数据引脚；
* 从触发器的一个输出到一个输出端口（流入本设计之外的触发器中）。

&#160; &#160; &#160; &#160; 流入触发器时钟引脚的路径称为时钟路径，时钟路径可以从时钟端口到触发器的时钟端子，也可以从时钟分频器或时钟发生器电路的输出到触发器的时钟端子等。

----

### 7 建立与保持

> STA主要是建立（setup）和保持（hold）分析，在一般术语中，建立是指在时钟边沿到达之前触发器D引脚上的数据应该稳定的时间。保持是指时钟边沿到达之后数据应保持稳定的时间。

#### 7.1 建立分析

&#160; &#160; &#160; &#160; 在STA领域中，建立是指在要求时间之前检查最新数据是否可用。因此，可以在任何终点进行建立检查，而不仅仅是触发器，即使在输出端也要进行建立检查。

&#160; &#160; &#160; &#160; 建立可以用如下通用的方式进行定义：数据需要在一些参考事件之前建立并使之可用。对于触发器，参考事件是时钟触发。对于其他终点，参考事件是“期望数据在那一点可用的时间”。

&#160; &#160; &#160; &#160; 参考以下电路：

![4](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BA%A6%E6%9D%9F/4.jpg)

&#160; &#160; &#160; &#160; 对于输出O，假设要求输出在时钟边沿到达后的6个时间单位可用。假设时钟周期为10，这个要求可以看做是假想触发器（FH——虚线所示）的建立要求为4（10-6），该假想触发器位于输出端口O之后。因此，可以在输出端进行建立检查。

#### 7.2 保持分析

&#160; &#160; &#160; &#160; 保持是指在当前信号的稳定性要求满足之后，检查最新的数据可以干扰当前信号的最早时间。因此，像建立一样，可以再任何终点进行保持检查，包括在输出端，不仅仅是触发器。

&#160; &#160; &#160; &#160; 保持可以用如下通用的方式进行定义：一些参考事件后数据需要保持和不干涉。对于触发器，参考事件是时钟触发。对于其他终点，参考事件是“允许数据在此点变化的时间”。

&#160; &#160; &#160; &#160; 上图中，对于输出O，假设输出在时钟边沿到达之后需要保持两个时间单位，这个要求可以看做是假想触发器（FH）的保持要求为2，该假想触发器位于输出端口O之后。因此，可以在输出端进行保持检查。

#### 7.3 其他分析

&#160; &#160; &#160; &#160; 建立检查可以确保移动最慢的数据也能及时到达并满足建立的标准。因此，数据路径可以计算最大延迟，也称为最大分析（max analysis）。由于建立检查考虑了最晚到达的数据，所以也称其为晚期分析（late analysis）。

&#160; &#160; &#160; &#160; 类似地，保持检查可以确保即使是移动最快的数据也不能干扰其他数据，同时期望数据保持稳定。因此，数据路径计算最小延迟，被称为最小分析（min analysis）。由于保持检查考虑到了最早到达的数据，所以也称其为早期分析（early analysis）。

&#160; &#160; &#160; &#160; STA的建立-保持分析也被称为最小-最大分析（min-max analysis）或早期-晚期分析（early-late analysis）。

----

### 8 裕度

&#160; &#160; &#160; &#160; 裕度是指任何超出要求的额外的余地。假设时刻6之前要求信号可用（建立分析），最后一个信号在时刻4到达。因此，信号有两个时间单位的额外余量，并且他也不会影响设计的运行。这个2被称为建立裕度（setup slack）。

&#160; &#160; &#160; &#160; 类似地，加入要求信号在时刻2之前保持稳定（保持分析）。最早的一个新信号在时刻5到达那里 ，因此该信号快了3个时间单位，这个3被称为保持裕度（hold slack）。

建立裕度 = 数据建立要求 - 最后一个到达的信号    
保持裕度 = 最早到达的信号 - 数据稳定要求

&#160; &#160; &#160; &#160; 如图所示：

![5](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BA%A6%E6%9D%9F/5.jpg)


&#160; &#160; &#160; &#160; 将E1作为需要捕获数据的边沿，S指示在E1之前建立要求的时间。所以最迟的数据应该在时刻S之前到达终点。假设最后一个到来的变化发生在Ma时刻，所以建立裕度是Ma-S的持续时间（由S-Ma测得）。

&#160; &#160; &#160; &#160; 就像数据必须在S之前到达一样，类似的，数据不应该如此早的到达，这样它可能会干扰前一个边沿捕获的数据。令E0为前一个边沿，假设前一个数据在此处被捕获。为了可靠地捕获前一个数据，当前数据不应该干扰它，直到满足从E0开始的保持要求。H代表E0之后的保持时间，因此当前数据只能在H时刻之后到来。假设最早一个到来的变化发生在Mi时刻，所以保持裕度是H-Mi的持续时间（由Mi-H测得）。

&#160; &#160; &#160; &#160; 正裕度意味着时序已经得到满足，而负裕度意味着时序尚未得到满足。根据所用的工具，报告的确切格式也不一样。但对于任何工具而言，它们都将通过路径跟踪延迟（建立分析的最大值和保持分析的最小值），并根踪信号要求的时间。然后它将比较两个数据并提供裕度值（正或负）。路径延迟或要求时间的计算还考虑了时钟路径的延迟，该延迟用于触发起点处的数据启动和终点处的数据捕获。

----

### 9 片上变化

&#160; &#160; &#160; &#160; 参考以下电路：

![6](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BA%A6%E6%9D%9F/6.jpg)

&#160; &#160; &#160; &#160; 在触发器F2上进行建立分析，必须考虑最慢的数据路径，所以需要考虑以下的最大延迟：

* 触发器F1的clk->Q的延迟；
* 组合逻辑C1；
* 互联网络。

&#160; &#160; &#160; &#160; 但是，只有当时钟触发信号到达时，数据才会通过触发器。因此我们必须用最大延迟考虑到达触发器F1的时钟路径。同样的时钟也达到了了触发器F2，并作为建立检查的参考事件。如果以最大延迟对待时钟路径，则参考事件也会延迟，这可能会使数据到达的裕度更大。所以对于触发器F2的时钟路径，应考虑最小延迟。

&#160; &#160; &#160; &#160; 实际上对于同一个时钟，一段（A->B->F1的CLK引脚）按最慢路径来考虑，而另一段（A->C->D->F2的时钟路径）按最快路径来考虑。

&#160; &#160; &#160; &#160; 对于同一网络不同段间的这种差异处理考虑了同一芯片在不同部分上的任何变化，并称之为片上变化（on-chip variation）。

&#160; &#160; &#160; &#160; 对于保持分析，数据路径必须是最快的，所以引进F1的时钟网络段也将以最快的速度来考虑，而进入F2的clk部分将以最慢的速度来考虑。

&#160; &#160; &#160; &#160; 这种片上变化减小了裕度。有一段时钟网络被启动触发器和捕获触发器共用（从clk端口到A）。无论是捕获触发器还是启动触发器，通过此段的时钟将具有相同的延迟。两个触发器共用的这段被认为具有相同的延迟。这样可以防止过度悲观。一些工具将片上变化应用到了整个时钟路径上，包括公用部分。之后，他们应用修正因子来补偿共用段中所考虑的延迟差异，这就是时钟网络悲观效应降低或时钟数悲观效应降低（clock network pessimism reduction or clock tree pessimism reduction）。

----
&#160; &#160; &#160; &#160; 告辞。

