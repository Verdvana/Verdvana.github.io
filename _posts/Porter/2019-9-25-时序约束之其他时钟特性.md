---
layout: post
title:  "时序约束之其他时钟特性"
date:   2019-9-25 9:57:10 +0700
tags:
  - Digital IC Design
  - Tcl
---

----

### 1 前言

&#160; &#160; &#160; &#160; 之前关于时钟的时序约束中，时钟都是理想的，即0到1的过渡都是瞬间的（方波），它们同时作用于设计中所有的触发器（所有边沿对齐），时钟生成电路和时钟实际作用电路之间也是无延迟的。但事实上时钟从来都没有处于理想状态。


&#160; &#160; &#160; &#160; 时钟在设计中形成一个使触发器高扇出的网络。因为不同的触发器与源时钟的电气距离也许不同,所以时钟不可能同时作用于所有的触发器。此外，若用单一的时钟缓冲器驱动所有触发器会产生巨大的电容负载而导致高压摆率。为了缓解这个问题，采用时钟树这个均衡的办法。在这一步将时钟缓冲器注入路径来平衡网络，以此均衡叶节点或触发器的延迟。这样每一个缓冲器都承担了一部分负载。这一步称为时钟树综合(亦称CTS，Cock Tree Synthesis)。

----

### 2 过渡时间

&#160; &#160; &#160; &#160; 下图为非理想时钟波形：

![1](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/1.jpg)

&#160; &#160; &#160; &#160; 时钟从0到1或从1到0的过渡都会在一个有限的时间内完成。

&#160; &#160; &#160; &#160; 信号变化的比率称为压摆率（slew）。压摆率通常表现了信号从一个状态转变为另一个状态所需要的过渡时间（transition time）。它也常用来表示电压变化值与总电压值的百分比。这些指标是测量中的國值范围。例如，设计者可以在30%~70%的区间上定义过渡时间，即信号从30%的电压值变化到70%的电压值所需要的时间。上升过渡时间是信号从0到1的过渡指标，下降过渡时间则表示相反的情况。同样也可以测量任意时钟沿之间的关系，假设当时钟达到一个预设的阈值（通常是电压值的50%）时它已经处于活动或非活动状态，这个数字表示阈值是一个参考量，并且不同的方法可指定不同的阈值。

&#160; &#160; &#160; &#160; 在CTS之前，由于时钟网络中的高负载，所以在时钟线路上进行任何延迟计算可能都只会得出毫无意义的高压摆率，还会影响建立和保持寄存器的时间。因此，STA中的压摆率设置假设已经先于CTS完成了。该数值同样可由CTS工具设定，以满足压摆率的预期值。可利用“set_ clock transition”约束来设定。


----

### 3 set_clock_transition

&#160; &#160; &#160; &#160; 在SDC中，时钟的过渡时间可利用“set_clock_transition”来描述，该指令的BNF为：

```tcl
srt_clock_transition    [-rise]
                        [-fall]
                        [-max]
                        [-min]
                        clock_list
                        transition_time
```

&#160; &#160; &#160; &#160; “-rise”选项用于提供时钟上升沿的过渡时间；“-fall”提供下降沿的过渡时间。“-max”和“-min”选项设定过渡时间的最大和最小操作条件。这四个选项可单独或一起使用，但必须注意他们不能与过渡时间矛盾，例如不能是负数或最大值不应小于最小值。过渡时间可以设定于一个时钟或一组时钟。设定的过渡时间适用于时钟网络，并且网络中时序电路元器件的时钟引脚数值是相同的。使用该约束的时钟应当匹配使用“create_clock”或者“create_generated_clock”约束设定的命名。

```tcl
# C1上升沿的过渡时间
set_clock_transition    -rise 0.2 [get_clocks C1]

# 最小和最大条件C2下降沿的过渡时间
set_clock_transition    -fall -min 0.2 [get_clock C2]
set_clock_transition    -fall -max 0.4 [get_clock C2]

# 设计中所有时钟的过渡（上升、下降、最大和最小）
set_clock_transition 0.3 [all_clocks]
```

&#160; &#160; &#160; &#160; 应当注意set_clock_transition仅用于预布局阶段，即时钟数综合完成之前。在时钟树生成之后，该命令不应与任何的后布局时序分析。

&#160; &#160; &#160; &#160; 通过该命令设定的过渡时间是从一个状态过渡为另一个状态所需的时间。然而过渡时间的阈值范围是特征库的属性。


----

### 4 偏斜和抖动

&#160; &#160; &#160; &#160; 一个由源产生的时钟信号不可能同时到达所有的触发器。到达不同触发器的时间不同可能是由于时钟网络里不同的路径、耦合电容或者其他PVT（工艺、电压、温度）上的变化而引起的。这会导致相同的时钟信号到达各个设备时的时钟沿无法对齐。时钟到达不同点的差异称为时钟偏斜。时钟偏斜存在于相同时钟（内部时钟）或不同（通常是同步的）时钟（交互时钟）之间的不同点上。

&#160; &#160; &#160; &#160; 在产生时钟的设备（如PLL）处，考虑到串扰、电磁干扰或PLL特性等因素时钟沿不具备确定性。这种时钟周期性的不良偏差称为抖动。由于偏斜或抖动问题，设计会违反建立和保持原则。如下图所示，这些偏差致使时钟沿在时标上滑动从而减少或增加有效时间以满足建立和/或保持要求。偏斜或抖动会导致不可预测性，即无法准确计算何时一个边沿能够到达触发器（时序设备）,这称为不确定度

----

### 5 set_clock_uncertainty

&#160; &#160; &#160; &#160; 在SDC中利用“set_clock_uncertainty”可将时钟偏斜和抖动模型化，该指令的BNF为：

```tcl
set_clock_uncertainty   [-form | -rise_form | -fall_from from_clock]
                        [-to | -rise_to | -fall_to to_clock]
                        [-setup]
                        [-hold]
                        [-rise]
                        [-fall]
                        [object_list]
                        Uncertainty_value
```

#### 5.1 内部时钟不确定度

&#160; &#160; &#160; &#160; 对单个时钟（内部时钟不确定度）的偏斜或抖动建模时，需要设定时钟名称、端口和引脚。当设定一个时钟时，其不确定度适用于所有由该时钟驱动的时序电路元器件。当适用于端口或者引脚时，则对所有端口或引脚扇出的时钟（及其相应的时序电路元器件）也适用。

&#160; &#160; &#160; &#160; 用户同样可以利用“-setup”和“-hold”选项对建立和保持检查设定不同的不确定度。对于内部时钟不确定度，建立抖动和偏斜的影响。而保持不受抖动的影响，仅受偏斜的影响。

&#160; &#160; &#160; &#160; 保持检查应在启动和捕获时钟的同一个沿上。因此，任何抖动会在完全相同的数量和方向上影响启动和捕获设备。所以，内部时钟保持分析不需要在意抖动。建议设置保持检查的不确定度小于建立检查的不确定度。

```tcl
# 内部时钟不确定度
set_clock_uncertainty 0.5 [get_clocks C1]
set_clock_uncertainty -setup 0.5 [get_clocks C2]
set_clock_uncertainty -hold 0.2 [get_clocks C2]
```
&#160; &#160; &#160; &#160; 在上面的例子中，如果有路径可以让其他时钟信号能够到达C1，那么若没有设定另外参数，则内部时钟不确定度同样可用于交互时钟不确定度。

#### 5.2 交互时钟不确定度

&#160; &#160; &#160; &#160; 对交互时钟不确定度建模时，源时钟可使用“-from”选项，而目的时钟可使用“-to”选项。

&#160; &#160; &#160; &#160;  如果设计者想针对不同的上升沿和下降沿分别建立不确定度，则可利用“-rise_from”、“-fall_from”、“-rise_to”、“-fall_to”这些选项。这些选项可作为补充加到SDC中。在这些选项之前可利用“-rise”和“-fall”进行设定。然而，利用“-from”设置上升沿条件或“-to”设置下降沿条件并不能保证很好的精确度。这或许是因为时间区间有可能在设置这些参数之前就从参照标准中被删除了。如今大多数静态时序分析工具把这些视为过时的选项。

&#160; &#160; &#160; &#160; 如果用户希望只对建立检查设定不确定度或者给建立和保持设定不同的值，则可以利用“-setup”和“-hold”选项。建立要包括两个时钟的抖动和偏斜。不像内部时钟，这种情况中两个时钟的抖动和偏斜都需要考虑保持，因为启动和捕获时钟都有自己的偏斜和抖动。最坏的情况下，它们可能是反向的，如对于建立来说，启动时钟有延迟而捕获时钟却提前了；对于保持来说，启动时钟提前了，捕获时钟却又延迟了。

&#160; &#160; &#160; &#160; 下列指令可用于设置所有由各自时钟驱动的触发器和锁存器的不确定度：

```tcl
# C1到C2的建立和保持不确定度
set_clock_uncertainty -from C1 -to C2 -setup 0.5
set_clock_uncertainty -from C1 -to C2 -hold 0.5

# C1上升沿到C2下降沿的不确定度
set_clock_uncertainty -rise_from C1 -fall_to C2 0.5
```

&#160; &#160; &#160; &#160; 在下图中给出了C1到C2和C2到C1的路径：

![2](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/2.jpg)

&#160; &#160; &#160; &#160; 常见的错误之一是设置了C1到C2的不确定度，这不会包括C2到C1的路径。不确定度必须涵盖所有源和目的时钟的组合：

```tcl
# C1和C2间的不确定度
set_clock_uncertainty -from C1 -to C2 0.5
set_clock_uncertainty -from C2 -to C1 0.5
```

&#160; &#160; &#160; &#160; 当交互时钟和内部时钟都设定了不确定度时，交互时钟优先级更高：

```tcl
set_clock_uncertainty 0.6 -from C2 -to C1
set_clock_uncertainty 0.5 [get_clocks C1]
```

&#160; &#160; &#160; &#160; 以上例子中时钟C1上有两个不同的不确定度。在所有C2到C1的路径中，交互时钟使用的不确定度为0.6，其优先级最高。在其它以C1为目的时钟的路径中，内部时钟的不确定度为0.5。

&#160; &#160; &#160; &#160; 不确定度的另一个要点是预布局和后布局两个阶段数值会发生变化。预布局阶段时钟数综合还未执行，不确定度必须考虑偏斜所带来的影响。而时钟数综合之后，偏斜部分已经确定，就不需要再作为不确定度来设置了。因此，后布局阶段的时钟不确定度一般小于预布局阶段的。

&#160; &#160; &#160; &#160; 下面的表格总结了会导致不确定度的因素（偏移和抖动）：

| | 内部时钟（源和目的时钟为同一个时钟） | 交互时钟（源和目的时钟为不同时钟） |
| --- | --- | --- |
| | 建立/保持 | 建立/保持 |
| 预布局 | 偏斜和抖动/偏斜 | 偏斜和抖动/偏斜和抖动 |
| 后布局 | 抖动/X | 抖动/抖动 |

----

### 6 时钟延迟

&#160; &#160; &#160; &#160; 在下图中给出了时钟路径和延迟：

![3](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/3.jpg)
![4](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/4.jpg)

&#160; &#160; &#160; &#160; 源时钟和时钟触发的设备引脚之间的延迟称为时钟延迟。这种延迟源于走线或者时钟树中源时钟和时钟引脚之间的元器件所产生的容性负载。
&#160; &#160; &#160; &#160; 时钟延迟包括两部分：

* 源延迟；
* 网络延迟。

&#160; &#160; &#160; &#160; 源延迟是指源时钟到定义的时钟点（在SDC中通过“create_clock”或“create_generated_clock”定义）的延迟。这个源可以是片内的也可以是片外的。

&#160; &#160; &#160; &#160; 网络延迟是指从被时钟定义的点到实际触发的时序设备所需要的时间。

&#160; &#160; &#160; &#160; 一个设备可能有多条时钟路径，这种情况下每条路径的延迟也不同。最长路径或者延迟最大的路径常称为后期路径，最短路径或延迟的最小路径常称为早期路径。总延迟等于源和网络延迟的综总和。根据设计阶段的情况，可以进行估算。

&#160; &#160; &#160; &#160; 因此，在时钟树综合之前或预布局阶段设定网络延迟可利用SDC约束“set_clock_latency”，来对时钟网络的延迟建模。

----

### 7 set_clock_latency

&#160; &#160; &#160; &#160; 该指令的BNF为：

```tcl
set_clock_latency   [-rise]
                    [-fall]
                    [-min]
                    [-max]
                    [-source]
                    [-late]
                    [-early]
                    [-clock clock_list]
                    delay
                    object_list
```

&#160; &#160; &#160; &#160; “-rise/-fall”选项指定了时钟上升沿和下降沿的延迟。“-min/max”选项可单独使用或一起使用，它们指定了操作条件最小和最大延迟。

&#160; &#160; &#160; &#160; 若需设定延迟的源组件，用户需要利用“-source”选项以及时钟名。在上图片外时钟源延迟路径中，假设端口定义SDC时钟的是C1，则源延迟表示的是从片外源到端口的延迟。可表示为：

```tcl
set_clock_latency   -source 0.5 [get_clock C1]
```

&#160; &#160; &#160; &#160; 在上图片内时钟源延迟路径中，如果从PLL到时钟定义处（即PLL的输出）有多条路径，则最长路径的延迟可利用“-late”选项表示，而最短路径的延迟可利用“-early”选项来表示：

```tcl
set_clock_latency   -source -early 0.5 [get_clock C1]
set_clock_latency   -source -late  0.1 [get_clock C1]
```

&#160; &#160; &#160; &#160; 当多个时钟交互时，源时钟延迟影响了建立和保持检查的方式和结果。通常一些消极的方法是在最新的源时钟和先前的目的时钟之间进行建立检查，并在先前的源时钟和最新的目的时钟之间进行保持检查。下图为具有延迟的多个时钟之间的建立和保持关系：

![5](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/5.jpg)

&#160; &#160; &#160; &#160; 当未设定“-sourse”选项时，该命令表示网络延迟。如前面所说，CTS中加入缓冲器为的是分配时钟网络中巨大的扇出量。这也是一种确保时钟网络中所有路径的延迟保持相近的办法。这些添加的缓冲器会导致时钟路径上有一些延迟。这种延迟可与网络延迟相同。因此实际上网络延迟是时钟网络的延迟，它通常由时钟数所导致。

&#160; &#160; &#160; &#160; 这适用于时钟、端口和引脚。对于上图中的片外时钟源延迟路径，以下指令表示时钟网络的延迟，这些延迟适用于所有由时钟触发的时序设备。

```tcl
# 网络延迟——上升沿（最大和最小条件）
set_clock_latency   0.5 -rise [get_clock C1]

# 网络延迟——下降沿（最大和最小条件）
set_clock_latency   0.5 -fall [get_clock C1]
```

&#160; &#160; &#160; &#160; 当用于端口或引脚时，表示延迟一直算到寄存器的时钟引脚，它们是由这些设计对象所扇出的，如果想使用一个特定的延迟值给时钟数的一部分，可以通过在引脚上设定延迟来实现，这样树的一部分会落入引脚扇出锥中。除端口和引脚以外，用户同样可以利用“-clock”选项设定关联时钟。当多个时钟通过 一个端口或引脚时，这非常有用：

```tcl
# A 扇出的寄存器时钟引脚的网络延迟
set_clock_latency   0.5 [get_ports A]

# B 扇出的寄存器时钟引脚的网络延迟
# by C1 and C2
set_clock_latency   1.0 -clock {C1 C2} [get_ports B]
```

&#160; &#160; &#160; &#160; SDC中源延迟和网络延迟在概念上是有差别的。源延迟仅可用于时钟，而网络延迟可用于时钟、端口或者引脚，源延迟仅能用于对早期和后期路径建模。最后，网络延迟是时钟树综合之前的一个预估延迟，CTS完成后并不需要再设定。CTS之后，建议使用“set_propagated_clock”指令，用它来指定时钟网络延迟需要的工具，以计算包括寄生电容在内的电路元器件。CTS之后实际的网络延迟也称为注入延迟。也就是说，源延迟仍需要在传递时钟的CTS之后设定。


----

### 8 时钟路径的单边性

&#160; &#160; &#160; &#160; 时钟的传递必须经过组合电路元器件。当通过缓冲器、与门/或门这类的门时，其敏感性（即过渡方向）是保持不变的。当通过反相器或与非门/或非门这类门时，其敏感性取反。在这两种情况下，可以沿着其路径计算出时钟的敏感性。这种基于传递的时钟，可以计算到达触发器的时钟沿的敏感性，这称为单边。

&#160; &#160; &#160; &#160; 正单边时钟是源时钟的上升沿可产生触发器时钟引脚的上升沿。负单边时钟时源时钟的上升沿或下降沿可产生对应时钟引脚的下降沿或上升沿（即反向）。

&#160; &#160; &#160; &#160; 然而在某些情况下，电路也可能无法计算出敏感性。如下图：

![6](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/6.jpg)


&#160; &#160; &#160; &#160; 这样的时钟路径称为非单边。对于这样的时钟路径，用户可以用“set_clock_sense”指令指定路径传递的敏感性（正或负）。

----

### 9 set_clock_sense

&#160; &#160; &#160; &#160; 该指令的BNF为：

```tcl
set_clock_sense     [-positive|-negative|-stop_propagation]
                    [-pulse pulse]
                    [-clock clock_list]
                    pin_list
```

&#160; &#160; &#160; &#160; 这个指令只在非单边时钟网络中才有意义。为了设定时钟网络的单边性，用户需要对时钟所通过的引脚进行命名。例如对于上图中的非单边时钟，SDC可以写成：

```tcl
set_clock_sense     -negative [get_pins XOR2/Z]
```

&#160; &#160; &#160; &#160; 如果多个时钟路径收敛于异或门这类元器件，那么上述指令意味着所有时钟的负边沿都被加入到分析中。要选择部分时钟可以利用“-clock”选项，例如：

```tcl
set_clock_sense     -positive -clock [get_clocks C1] [get_pins XOR1/Z]
set_clock_sense     -negative -clock [get_clocks C2] [get_pins XOR2/Z]
```
&#160; &#160; &#160; &#160; 与“-positive”和“-negative”选项互斥的是“-stop_propagation”。如果需要禁用部分时钟的传递可利用这个选项：

```tcl
set_clock_sense     -stop_propagation -clock [get_clocks C3]\[get_pins XOR1/Z]
```

&#160; &#160; &#160; &#160; 例如在使用PLL时，会有多个时钟输出，有时候不希望某个生成的时钟到达一组特定的寄存器，就可以用上述的语句禁用。

&#160; &#160; &#160; &#160; 在[时序约束之生成时钟](http://verdvana.top/fpga/digital%20ic%20design/2019/09/23/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E7%94%9F%E6%88%90%E6%97%B6%E9%92%9F.html)的第四部分门控时钟里，使用了“create_generated_clock”建立脉冲。另一种建立脉冲的方法是在“set_clock_sense”中利用“-pulse”选项：

```tcl
set_clock_sense     -pulse rise_triggered_high_pulse [get_pins AN1/Z]
```

&#160; &#160; &#160; &#160; “-pulse”选项可以在以下选项中选择一个值：

* rise_triggered_high_pulse；
* rise_triggered_low_pulse；
* fall_triggered_high_pulse；
* fall_triggered_low_pulse。

&#160; &#160; &#160; &#160; 上升沿触发脉冲是源时钟的上升沿有效，反之下降沿触发则是下降沿有效。下图给了不同类型的脉冲波形：

![7](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B9%8B%E5%85%B6%E4%BB%96%E6%97%B6%E9%92%9F%E7%89%B9%E6%80%A7/7.jpg)


&#160; &#160; &#160; &#160; 针对脉冲使用“set_clock_sense”优于“create_generated_clock”，**因为这样不会多创建一个时钟而产生一个多余的域**。对于一个脉冲，无论使用什么方法，脉冲宽度都假设为0。而当仅使用set_clock_sense时，实际的脉冲宽度是基于上升和下降延迟的差值计算得出的。用户可以设置产生脉冲的引脚和延迟。例如上述的“set_clock_sense”补全则为：

```tcl
set_clock_sense     -rise 0.2 [get_pins AN1/Z]
set_clock_sense     -fall 0.9 [get_pins AN1/Z]
```

&#160; &#160; &#160; &#160; 则脉冲宽度为0.7ns。一般脉冲宽度的计算方法为：

Pulse_width = | rise_latency - fall_latency |

----

### 10 理想网络

&#160; &#160; &#160; &#160; 理想元器件、引脚和线网的网络称为理想网络，可利用“set_ideal_network”约束来定义，该指令的BNF为：

```tcl
set_ideal_network   [-no_propagate]
                    object_list
```

&#160; &#160; &#160; &#160; 这个可以设置在任何层级的端口、元器件或者网络上。其可以设置在任何内部引脚上，但不能设置在层级边界的引脚上。当设置了这个约束，则源的可递扇出所有对象（网络、引脚和元器件）也是理想的。通常理想网络通过所有组合电路元器件并且停止在时序电路元器件上。为防止任何传递通过组合电路元器件，可利用“-no_propagate”选项。

&#160; &#160; &#160; &#160; 默认情况下，理想网络的过渡和延迟都假设为0,。可通过“set_ideal_transition”和“set_ideal_latency”约束来设定特定的值。

----
&#160; &#160; &#160; &#160; 告辞。

