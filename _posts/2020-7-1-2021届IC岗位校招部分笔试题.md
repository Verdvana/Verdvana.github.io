---
layout: post
title:  "2021届IC岗位校招部分笔试题"
date:   2020-7-1 20:48:10 +0700
tags:
  - Digital IC Design
---

-------

## 1 乐鑫提前批 

### 1.1 若要将一异或非门当做反相器（非门）使用，则输入端A、B的连接方式是（）

A. A或B中有一个接“0”；    
B. A和B并联使用；    
C. 不能实现；    
D. A或B中有一个接“1”。    

----

### 1.2 对于半导体存储器，下列叙述正确的是（）

A. 半导体存储器的数据读写是依靠地址译码器选中相应的存储单元，对单元进行读写的，由于是数字信号，因此从存储矩阵中获取的信号可以不经处理，送到相应的数字逻辑电路中；    
B. 随机存取的存储器断电后数据丢失，只读存储器断电后数据不会丢失，通电后又可以继续使用；    
C. 可编程的只读存储器使用电进行编程，用紫外线可以擦除原来的信息；     
D. 随机存取的存储器，使用的时候需要进行刷新和再生。    

----

### 1.3 TTL门电路组成的JK触发器，时钟端接5kHz脉冲，J与K悬空，则输出Q的频率为（）

A. 5kHz；     
B. 10kHz；    
C. 无法预测；    
D. 2.5kHz。    

----

### 1.4 后一级的输入电容大小会影响（）功耗

A. 短路电流；    
B. 动态；    
C. 静态；    
D. 漏电流。    

----

### 1.5 在时序电路的状态转换表中，若状态数N=3，则状态变量数最少为（）

A. 4    
B. 8    
C. 2    
D. 16    

----

### 1.6 可综合的verilog语法包括（）`多选`

A. wait；    
B. time；    
C. assign；    
D. generate；    
E. always；    
F. for；    
G. initial。    

----

### 1.7 在芯片设计流程中，通常会进行后仿真（post-simulation）。关于后仿的作用，以下说法正确的是（）`多选`

A. 抽检netlist是否和预期功能一致；    
B. 抽检综合工具是否存在bug导致生成了错误的netlist；    
C. 抽检电路中是否存在大量的glitch；    
D. 抽检时序是否有违规。    

----

### 1.8 以下方法哪些是进行面积优化（）`多选`

A. 逻辑优化；    
B. 寄存器配平；    
C. 关键路径优化；    
D. 串行化；    
E. 流水线设计；    
F. 资源共享。    

----

### 1.9 在满足换路定则的前提下，以下关于电感的说法，正确的是（）`多选`

A. 电压可以跳变；    
B. 电流不能跳变；    
C. 电流可以跳变；    
D. 电压不能跳变。    

----

### 1.10 以下关于电容的说法正确的是（）`多选`

A. 不能储能；    
B. 为有源器件；    
C. 为无源器件；    
D. 可以储能。    

----

### 1.11 二进制数A、B均为正数（一位符号位，七位数字），若A-B=10001001二进制，则（）更大

A. A；    
B. B。    

----

### 1.12 写出verilog表达式以实现对应电路的逻辑功能：

----

### 1.13 如下电路实现的逻辑功能为（）进制计数器

----

### 1.14 某电路有A、B、C、D、E、F六个状态，A和C、D和F、E和B、F和C分别等价，则可简化为（）个状态

----

### 1.15 ~A~B~C+A+B+C=（）

----

### 1.16 八进制数34.2的等值二进制数为（）；十进制数98的等值二进制数为（）；8421BCD码为（）

----

### 1.17 如下电路中，β=100，Ube=0.7V，Rb=50kohm，可求得Uo为（）

----

### 1.18 下图中时钟周期为0.5ns，寄存器的setup及hold time均为0.1ns，有hold违例的路径是从（）到（）

----

### 1.19 A的原码为011010，则2A对应的8位原码形式为（），-A的8位补码为（）

----

### 1.20 一个8位数模转换器（DAC）的最小输出电压增量为0.02V，当输入代码为11011010时，输出电压Vo=（）V；ADC的两个最重要的指标是（）和（）

----

### 1.21 如下数学表达式：send+more=money，每个字母代表一位从0到9的数字，首位不能为0，且每个字母所代表的数字不同，请用SystemVerilog的随机约束来求解每个数字所代表的值

* 要求：
	* 需要写出求解class SendMoreMoney及其约束，将代码写在TODO下面；
	* 要求运行下面SystemVerilog测试代码后，你的代码可以得出正确结果（不必手算出结果）：
	```verilog
	initial begin
		SendMoreMoney test;
		test = new();
		test.randomize();
		//得到test s/e/n/d/m/o/r/y的正确值
	end

	class SendMoreMoney
		rand bit [3:0]	s,e,n,d,m,o,r,y;

	//TODO:
	```



----

### 1.22 通过深度为4的异步双端口FIFO，实现跨时钟域的数据（32bit）传递。

* 输入信号包括：wr_clk,rd_clk,rd_en,wr_en,wr_data;
* 输出信号包括：rd_data,fifo_full,fifo_empty;

>```verilog
>//------------------------------------------------------------------------------
>//
>//Module Name:					Asy_FIFO.v
>//Department:					Xidian University
>//Function Description:	   		异步FIFO
>//
>//------------------------------------------------------------------------------
>//
>//Version 	Design		Coding		Simulata	  Review		Rel data
>//V1.0		Verdvana	Verdvana	Verdvana		        	2019-6-22
>//
>//-----------------------------------------------------------------------------------
>
>`timescale 1ns/1ns
>
>module Asy_FIFO #(
>parameter DATA_WIDTH = 32,
>parameter ADDR_WIDTH = 4
>)(
>/************* 时钟 *************/
>	input							wr_clk,
>	input							rd_clk,
>/************* 使能 *************/	
>	input							wr_en,
>	input							rd_en,
>/************* 复位 *************/	
>	input							rst_n,
>/************* 标志 *************/	
>	output							full,
>	output							empty,
>/************* 数据 *************/	
>	input		[DATA_WIDTH-1:0] 	data_in,
>	output reg	[DATA_WIDTH-1:0] 	data_out
>
>);
>
>	//==============================================================
>	//信號定义
>
>	parameter FIFO_DEPTH = ( 1 << ADDR_WIDTH ); 		//FIFO深度定义
>	
>	reg 	[DATA_WIDTH-1:0]	fifo [FIFO_DEPTH];		//寄存器组，存储数据
>
>	logic 						wr_en_r;				//写使能寄存
>	logic						rd_en_r;				//读使能寄存
>	
>	logic	[ADDR_WIDTH-1:0]	wr_addr;				//写地址
>	logic	[ADDR_WIDTH-1:0]	rd_addr;				//读地址
>
>	logic	[ADDR_WIDTH  :0]	wr_pointer;				//写指针	
>	logic	[ADDR_WIDTH  :0]	rd_pointer;				//读指针
>
>	logic 	[ADDR_WIDTH  :0]	wr_addr_gray;			//写地址格雷码
>	logic 	[ADDR_WIDTH  :0]	rd_addr_gray;			//读地址格雷码
>
>	logic  	[ADDR_WIDTH  :0]	wr_addr_gray_d1;		//消除亚稳态一级寄存器
>	logic  	[ADDR_WIDTH  :0]	wr_addr_gray_d2;		//消除亚稳态二级寄存器
>	logic  	[ADDR_WIDTH  :0]	rd_addr_gray_d1;		//消除亚稳态一级寄存器
>	logic  	[ADDR_WIDTH  :0]	rd_addr_gray_d2;		//消除亚稳态二级寄存器	
>
>
>	//==============================================================
>	//寄存使能信号
>
>	always_ff@(posedge wr_clk)begin
>		wr_en_r 	<=	#1 wr_en;
>	end
>
>	always_ff@(posedge rd_clk)begin
>		rd_en_r		<=	#1 rd_en;
>	end
>
>
>	//==============================================================
>	//读写指针递增
>
>	always_ff@(posedge wr_clk, negedge rst_n) begin
>		if(!rst_n)
>			wr_pointer <= #1 'h0;
>		else if(wr_en_r && (~full))
>			wr_pointer <= #1 wr_pointer + 1;
>		else 
>			wr_pointer <= #1 wr_pointer;
>	end
>
>
>	always_ff@(posedge rd_clk, negedge rst_n) begin
>		if(!rst_n)
>			rd_pointer <= #1 'h0;
>		else if(rd_en_r && (~empty))
>			rd_pointer <= #1 rd_pointer + 1;
>		else 
>			rd_pointer <= #1 rd_pointer;
>	end
>
>
>	//==============================================================
>	//产生读写地址
>
>	assign wr_addr = wr_pointer[ADDR_WIDTH-1:0];	//写地址为写指针去掉最高位
>	assign rd_addr = rd_pointer[ADDR_WIDTH-1:0];	//读地址为读指针去掉最高位
>
>
>
>	//==============================================================
>	//读写
>	
>	always_ff@(posedge wr_clk) begin
>		if(wr_en_r && (~full))
>			fifo[wr_addr] <= #1 data_in;
>	end
>
>
>	always_ff@(posedge rd_clk) begin
>		if(rd_en_r && (~empty))
>			data_out <= #1 fifo[rd_addr];
>	end
>
>
>	//==============================================================
>	//产生读写地址格雷码
>
>	assign wr_addr_gray = (wr_pointer >> 1) ^ wr_pointer;	//产生写地址格雷码
>	assign rd_addr_gray = (rd_pointer >> 1) ^ rd_pointer;	//产生读地址格雷码
>
>
>	//==============================================================
>	//寫指针格雷码同步化
>
>	always_ff@(posedge rd_clk ) begin
>		wr_addr_gray_d1 <= #1 wr_addr_gray;		//将写地址的格雷码转移到读时钟域，方便与读地址格雷码比较
>		wr_addr_gray_d2 <= #1 wr_addr_gray_d1; 	//两级触发消除亚稳态                               
>	end
>
>
>	//==============================================================
>	//读指针格雷码同步化
>
>	always_ff@(posedge wr_clk) begin
>		rd_addr_gray_d1 <= #1 rd_addr_gray;		//将读地址的格雷码转移到写时钟域，方便与写地址格雷码比较
>		rd_addr_gray_d2 <= #1 rd_addr_gray_d1;	//两级触发消除亚稳态                               
>	end
>
>
>	//==============================================================
>	//空满判断
>
>	assign full = (wr_addr_gray == {~(rd_addr_gray_d2[ADDR_WIDTH-:2]),rd_addr_gray_d2[ADDR_WIDTH-2:0]});	//写地址格雷码与读地址同步后的格雷码的高两位不同 即为满
>	assign empty = ( rd_addr_gray == wr_addr_gray_d2 );	
>
>endmodule
>```

----
&#160; &#160; &#160; &#160; 告辞