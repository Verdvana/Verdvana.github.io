---
layout: post
title:  "数字IC设计/FPGA笔试代码汇总"
date:   2020-2-26 10:53:10 +0700
tags:
  - Digital IC Design
  - Verilog
---

-------

### 1 前言 

&#160; &#160; &#160; &#160; 总结一下数字IC设计和FPGA开发等笔试代码题。

----

### 边沿检测

&#160; &#160; &#160; &#160; 位宽可定制的多bit信号边沿检测，输出一个周期宽度的脉冲信号：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Edge_Detection.sv
//Department:					Xidian University
//Function Description:	   		边沿检测
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana		Verdvana      			2020-02-26
//
//-----------------------------------------------------------------------------------
`timescale 1ns/1ns

module Edge_Detection #(
    parameter   BIT_WIDTH = 8
)(
    input                   clk,
    input                   rst_n,

    input  [BIT_WIDTH-1:0]  edge_in,    //输入
    output [BIT_WIDTH-1:0]  edge_p,     //上升沿输出
    output [BIT_WIDTH-1:0]  edge_n      //下降沿输出
);

    logic [BIT_WIDTH-1:0] edge_r1,edge_r2;  //两级寄存

    always_ff@(posedge clk, negedge rst_n) begin
        if(!rst_n) begin
            edge_r1 <= #1 '0;
            edge_r2 <= #1 '0;
        end
        else begin
            edge_r1 <= #1 edge_in;
            edge_r2 <= #1 edge_r1;
        end
    end

    assign edge_p = edge_r1 & ~edge_r2;
    assign edge_n = ~edge_r1 & edge_r2;

endmodule
```

----

### 串转并

&#160; &#160; &#160; &#160; 位宽可定制的串转并模块：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Deserializer.v
//Department:					Xidian University
//Function Description:	        解串器
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana	Verdvana		  			2020-02-26
//
//-----------------------------------------------------------------------------------
//
//Version	Modified History
//V1.0		位宽可定制的串转并模块
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns

module Deserializer #(
    parameter   DATA_WIDTH = 8,
                MSB_LSB    = 1  //MSB先为1，LSB先为0
)(
    input                       clk,
    input                       rst_n,

    input                       data_in,
    output reg [DATA_WIDTH-1:0] data_out
);

    //位宽计算函数
    function integer clogb2 (input integer depth);
    begin
        for (clogb2=0; depth>0; clogb2=clogb2+1) 
            depth = depth >>1;                          
    end
    endfunction

    logic [clogb2(DATA_WIDTH)-1:0] cnt;

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            cnt <= #1 '0;
        else if(cnt >= DATA_WIDTH-1)
            cnt <= #1 '0;
        else
            cnt <= #1 cnt + 1;
    end

    logic [DATA_WIDTH-1:0] data_out_r;

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            data_out_r <= #1 '0;
        else
            case(MSB_LSB)
                1'b0:data_out_r <= #1 {data_in,data_out_r[DATA_WIDTH-1:1]};
                1'b1:data_out_r <= #1 {data_out_r[DATA_WIDTH-2:0],data_in};
            endcase
    end

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            data_out <= #1 '0;
        else if(cnt == DATA_WIDTH-1)
            data_out <= #1 data_out_r;
        else
            data_out <= #1 data_out;
    end

endmodule
```

----

### 2 同步FIFO

&#160; &#160; &#160; &#160; 位宽、深度可定制的同步FIFO：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Syn_FIFO.sv
//Department:					Xidian University
//Function Description:	   		同步FIFO
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana		Verdvana      			2019-11-2
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns 

module Syn_FIFO# (
	parameter DATA_WIDTH = 8,					//定义FIFO数据位宽、地址位宽
	parameter ADDR_WIDTH = 8
)(
	/************ 时钟和复位 ************/
	input							clk,		//时钟
	input							rst_n,		//复位						
	/************ 读写使能 *************/					
	input							wr_en,		//写使能
	input							rd_en,		//读使能
	/*********** 数据输入输出 ***********/	
	input  		[DATA_WIDTH-1:0]	data_in,	//数据输入
	output reg 	[DATA_WIDTH-1:0]	data_out,	//数据输出
	/************* 标志位 *************/	
	output							full,		//满标志
	output							empty 		//空标志
);


	
	parameter FIFO_DEPTH = (1 << ADDR_WIDTH); 	//根据FIFO地址位宽定制FIFO深度

	logic						wr_en_r;
	logic						rd_en_r;
	logic	[ADDR_WIDTH  :0] 	wr_pointer;		//写指针
	logic  	[ADDR_WIDTH  :0] 	rd_pointer;		//读指针
	logic	[ADDR_WIDTH-1:0]	wr_addr;
	logic	[ADDR_WIDTH-1:0]	rd_addr;


	reg 	[DATA_WIDTH-1:0]	fifo [FIFO_DEPTH];	//寄存器组


	//==============================================================
	//使能同步

	always_ff@(posedge clk, negedge rst_n) begin
		if(!rst_n) begin
			wr_en_r <= #1 1'b0;
			rd_en_r <= #1 1'b0;
		end
		else begin
			wr_en_r <= #1 wr_en;
      		rd_en_r <= #1 rd_en;
		end	
	end	


	//==============================================================
	//指针递增

	always_ff@(posedge clk, negedge rst_n) begin
		if(!rst_n)begin
			wr_pointer <= #1 '0;
		end
		else if(wr_en_r && (!full)) begin
			wr_pointer <= #1 wr_pointer + 1;
		end
	end

	always_ff@(posedge clk, negedge rst_n) begin
		if(!rst_n)begin
			rd_pointer <= #1 '0;
		end
		else if(rd_en_r && (!empty)) begin
			rd_pointer <= #1 rd_pointer + 1;
		end
	end


	//==============================================================
	//读写地址

	assign	wr_addr = wr_pointer[ADDR_WIDTH-1:0];
	assign  rd_addr = rd_pointer[ADDR_WIDTH-1:0];


	//==============================================================
	//读写

	always_ff@(posedge clk)begin
		if(wr_en_r && (!full))
			fifo[wr_addr] <= #1 data_in;
	end

	always_ff@(posedge clk)begin
		if(rd_en_r && (!empty))
			data_out <= #1 fifo[rd_addr];
	end


	//==============================================================
	//空满判断

	assign full  = ( wr_pointer == {~rd_pointer[ADDR_WIDTH],rd_pointer[ADDR_WIDTH-1:0]} );
	assign empty = ( wr_pointer == rd_pointer );


endmodule
```

----

### 3 异步FIFO

&#160; &#160; &#160; &#160; 位宽、深度可定制的异步FIFO：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Asy_FIFO.v
//Department:					Xidian University
//Function Description:	   		异步FIFO
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana	Verdvana		        	2019-6-22
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns

module Asy_FIFO #(
parameter DATA_WIDTH = 8,
parameter ADDR_WIDTH = 8
)(
/************* 时钟 *************/
	input							wr_clk,
	input							rd_clk,
/************* 使能 *************/	
	input							wr_en,
	input							rd_en,
/************* 复位 *************/	
	input							rst_n,
/************* 标志 *************/	
	output							full,
	output							empty,
/************* 数据 *************/	
	input		[DATA_WIDTH-1:0] 	data_in,
	output reg	[DATA_WIDTH-1:0] 	data_out

);

	//==============================================================
	//信號定义

	parameter FIFO_DEPTH = ( 1 << ADDR_WIDTH ); 		//FIFO深度定义
	
	reg 	[DATA_WIDTH-1:0]	fifo [FIFO_DEPTH];		//寄存器组，存储数据

	logic 						wr_en_r;				//写使能寄存
	logic						rd_en_r;				//读使能寄存
	
	logic	[ADDR_WIDTH-1:0]	wr_addr;				//写地址
	logic	[ADDR_WIDTH-1:0]	rd_addr;				//读地址

	logic	[ADDR_WIDTH  :0]	wr_pointer;				//写指针	
	logic	[ADDR_WIDTH  :0]	rd_pointer;				//读指针

	logic 	[ADDR_WIDTH  :0]	wr_addr_gray;			//写地址格雷码
	logic 	[ADDR_WIDTH  :0]	rd_addr_gray;			//读地址格雷码

	logic  	[ADDR_WIDTH  :0]	wr_addr_gray_d1;		//消除亚稳态一级寄存器
	logic  	[ADDR_WIDTH  :0]	wr_addr_gray_d2;		//消除亚稳态二级寄存器
	logic  	[ADDR_WIDTH  :0]	rd_addr_gray_d1;		//消除亚稳态一级寄存器
	logic  	[ADDR_WIDTH  :0]	rd_addr_gray_d2;		//消除亚稳态二级寄存器	


	//==============================================================
	//寄存使能信号

	always_ff@(posedge wr_clk)begin
		wr_en_r 	<=	#1 wr_en;
	end

	always_ff@(posedge rd_clk)begin
		rd_en_r		<=	#1 rd_en;
	end


	//==============================================================
	//读写指针递增

	always_ff@(posedge wr_clk, negedge rst_n) begin
		if(!rst_n)
			wr_pointer <= #1 'h0;
		else if(wr_en_r && (~full))
			wr_pointer <= #1 wr_pointer + 1;
		else 
			wr_pointer <= #1 wr_pointer;
	end


	always_ff@(posedge rd_clk, negedge rst_n) begin
		if(!rst_n)
			rd_pointer <= #1 'h0;
		else if(rd_en_r && (~empty))
			rd_pointer <= #1 rd_pointer + 1;
		else 
			rd_pointer <= #1 rd_pointer;
	end


	//==============================================================
	//产生读写地址

	assign wr_addr = wr_pointer[ADDR_WIDTH-1:0];	//写地址为写指针去掉最高位
	assign rd_addr = rd_pointer[ADDR_WIDTH-1:0];	//读地址为读指针去掉最高位



	//==============================================================
	//读写
	
	always_ff@(posedge wr_clk) begin
		if(wr_en_r && (~full))
			fifo[wr_addr] <= #1 data_in;
	end


	always_ff@(posedge rd_clk) begin
		if(rd_en_r && (~empty))
			data_out <= #1 fifo[rd_addr];
	end


	//==============================================================
	//产生读写地址格雷码

	assign wr_addr_gray = (wr_pointer >> 1) ^ wr_pointer;	//产生写地址格雷码
	assign rd_addr_gray = (rd_pointer >> 1) ^ rd_pointer;	//产生读地址格雷码


	//==============================================================
	//寫指针格雷码同步化

	always_ff@(posedge rd_clk ) begin
		wr_addr_gray_d1 <= #1 wr_addr_gray;		//将写地址的格雷码转移到读时钟域，方便与读地址格雷码比较
		wr_addr_gray_d2 <= #1 wr_addr_gray_d1; 	//两级触发消除亚稳态                               
	end


	//==============================================================
	//读指针格雷码同步化

	always_ff@(posedge wr_clk) begin
		rd_addr_gray_d1 <= #1 rd_addr_gray;		//将读地址的格雷码转移到写时钟域，方便与写地址格雷码比较
		rd_addr_gray_d2 <= #1 rd_addr_gray_d1;	//两级触发消除亚稳态                               
	end


	//==============================================================
	//空满判断

	assign full = (wr_addr_gray == {~(rd_addr_gray_d2[ADDR_WIDTH-:2]),rd_addr_gray_d2[ADDR_WIDTH-2:0]});	//写地址格雷码与读地址同步后的格雷码的高两位不同 即为满
	assign empty = ( rd_addr_gray == wr_addr_gray_d2 );	

endmodule
```


----

### 4 异步双端口RAM

&#160; &#160; &#160; &#160; 位宽、深度可定制，A口读出，B口写入，支持片选和读写请求的异步双端口RAM：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Asy_DPRAM.v
//Department:					Xidian University
//Function Description:	   		异步双端口RAM
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana	Verdvana		        	2020-2-26
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns

module Asy_DPRAM #(
    parameter   DATA_WIDTH = 8,
                ADDR_WIDTH = 8
)(
    input                       clk_a,
    input                       clk_b,
    input                       rst_n,
    input                       cs_n,

    input                       en_a,
    input      [ADDR_WIDTH-1:0] addr_a,
    output reg [DATA_WIDTH-1:0] data_a,

    input                       en_b,
    input      [ADDR_WIDTH-1:0] addr_b,
    input      [DATA_WIDTH-1:0] data_b,
);

    parameter DATA_DIPTH = 1 << ADDR_WIDTH;

    reg [DATA_WIDTH-1:0]    ram [DATA_DIPTH];

    always_ff@(posedge clk_a, negedge rst_n)begin
        if(!rst_n)
            data_a <= #1 '0;
        else if(!cs_n&en_a)
            data_a <= #1 ram[addr_a];
        else
            data_a <= #1 data_a;
    end

    always_ff@(posedge clk_b, negedge rst_n) begin
        if(!rst_n)begin
            for(int i=0;i<DATA_DIPTH;i++)
                ram[addr_b] <= #1 '0;
        end
        else if(!cs_n&en_b)
            ram[addr_b] <= #1 data_b;
    end

endmodule
```


----

### 5 任意奇数分频器

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Odd_Frequency_Divider.v
//Department:					Xidian University
//Function Description:	   		任意奇数分频器
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana	Verdvana		        	2020-2-22
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns

module Odd_Frequency_Divider #(
    parameter   DIV_COEFF   = 3
)(
    input       clk,
    input       rst_n,

    input       en,
    output      clk_out
);

    //位宽计算函数
    function integer clogb2 (input integer depth);
    begin
        for (clogb2=0; depth>0; clogb2=clogb2+1) 
            depth = depth >>1;                          
    end
    endfunction

    reg [clogb2(DIV_COEFF)-1:0] cnt;

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            cnt <= #1 '0;
        else if(cnt >= DIV_COEFF-1)
            cnt <= #1 '0;
        else
            cnt <= cnt + 1;
    end

    logic clk_pos,clk_neg;

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            clk_pos <= #1 '0;
        else if(cnt <= (DIV_COEFF-1)/2)
            clk_pos <= #1 '1;
        else
            clk_pos <= #1 '0;
    end

    always_ff@(negedge clk, negedge rst_n)begin
        if(!rst_n)
            clk_neg <= #1 '0;
        else if(cnt <= (DIV_COEFF-1)/2)
            clk_neg <= #1 '1;
        else
            clk_neg <= #1 '0;
    end

    assign clk_out = clk_pos & clk_neg;


endmodule
```

----



----
&#160; &#160; &#160; &#160; 告辞