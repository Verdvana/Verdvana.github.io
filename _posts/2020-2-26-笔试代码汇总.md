---
layout: post
title:  "笔试代码汇总"
date:   2020-2-26 10:53:10 +0700
tags:
  - Digital IC Design
  - Verilog
---

-------

### 1 前言 

&#160; &#160; &#160; &#160; 总结一下数字IC设计和FPGA开发等笔试代码题。

----

### 2 同步FIFO

&#160; &#160; &#160; &#160; 位宽、深度可定制的同步FIFO：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Syn_FIFO.sv
//Department:					Xidian University
//Function Description:	   		同步FIFO
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana		Verdvana      			2019-11-2
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns 

module Syn_FIFO# (
	parameter DATA_WIDTH = 8,					//定义FIFO数据位宽、地址位宽
	parameter ADDR_WIDTH = 8
)(
	/************ 时钟和复位 ************/
	input							clk,		//时钟
	input							rst_n,		//复位						
	/************ 读写使能 *************/					
	input							wr_en,		//写使能
	input							rd_en,		//读使能
	/*********** 数据输入输出 ***********/	
	input  		[DATA_WIDTH-1:0]	data_in,	//数据输入
	output reg 	[DATA_WIDTH-1:0]	data_out,	//数据输出
	/************* 标志位 *************/	
	output							full,		//满标志
	output							empty 		//空标志
);


	
	parameter FIFO_DEPTH = (1 << ADDR_WIDTH); 	//根据FIFO地址位宽定制FIFO深度

	logic						wr_en_r;
	logic						rd_en_r;
	logic	[ADDR_WIDTH  :0] 	wr_pointer;		//写指针
	logic  	[ADDR_WIDTH  :0] 	rd_pointer;		//读指针
	logic	[ADDR_WIDTH-1:0]	wr_addr;
	logic	[ADDR_WIDTH-1:0]	rd_addr;


	reg 	[DATA_WIDTH-1:0]	fifo [FIFO_DEPTH];	//寄存器组


	//==============================================================
	//使能同步

	always_ff@(posedge clk, negedge rst_n) begin
		if(!rst_n) begin
			wr_en_r <= #1 1'b0;
			rd_en_r <= #1 1'b0;
		end
		else begin
			wr_en_r <= #1 wr_en;
      		rd_en_r <= #1 rd_en;
		end	
	end	


	//==============================================================
	//指针递增

	always_ff@(posedge clk, negedge rst_n) begin
		if(!rst_n)begin
			wr_pointer <= #1 '0;
		end
		else if(wr_en_r && (!full)) begin
			wr_pointer <= #1 wr_pointer + 1;
		end
	end

	always_ff@(posedge clk, negedge rst_n) begin
		if(!rst_n)begin
			rd_pointer <= #1 '0;
		end
		else if(rd_en_r && (!empty)) begin
			rd_pointer <= #1 rd_pointer + 1;
		end
	end


	//==============================================================
	//读写地址

	assign	wr_addr = wr_pointer[ADDR_WIDTH-1:0];
	assign  rd_addr = rd_pointer[ADDR_WIDTH-1:0];


	//==============================================================
	//读写

	always_ff@(posedge clk)begin
		if(wr_en_r && (!full))
			fifo[wr_addr] <= #1 data_in;
	end

	always_ff@(posedge clk)begin
		if(rd_en_r && (!empty))
			data_out <= #1 fifo[rd_addr];
	end


	//==============================================================
	//空满判断

	assign full  = ( wr_pointer == {~rd_pointer[ADDR_WIDTH],rd_pointer[ADDR_WIDTH-1:0]} );
	assign empty = ( wr_pointer == rd_pointer );


endmodule
```

----

### 3 异步FIFO

&#160; &#160; &#160; &#160; 位宽、深度可定制的异步FIFO：

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Asy_FIFO.v
//Department:					Xidian University
//Function Description:	   		异步FIFO
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana	Verdvana		        	2019-6-22
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns

module Asy_FIFO #(
parameter DATA_WIDTH = 8,
parameter ADDR_WIDTH = 8
)(
/************* 时钟 *************/
	input							wr_clk,
	input							rd_clk,
/************* 使能 *************/	
	input							wr_en,
	input							rd_en,
/************* 复位 *************/	
	input							rst_n,
/************* 标志 *************/	
	output							full,
	output							empty,
/************* 数据 *************/	
	input		[DATA_WIDTH-1:0] 	data_in,
	output reg	[DATA_WIDTH-1:0] 	data_out

);

	//==============================================================
	//信號定义

	parameter FIFO_DEPTH = ( 1 << ADDR_WIDTH ); 		//FIFO深度定义
	
	reg 	[DATA_WIDTH-1:0]	fifo [FIFO_DEPTH];		//寄存器组，存储数据

	logic 						wr_en_r;				//写使能寄存
	logic						rd_en_r;				//读使能寄存
	
	logic	[ADDR_WIDTH-1:0]	wr_addr;				//写地址
	logic	[ADDR_WIDTH-1:0]	rd_addr;				//读地址

	logic	[ADDR_WIDTH  :0]	wr_pointer;				//写指针	
	logic	[ADDR_WIDTH  :0]	rd_pointer;				//读指针

	logic 	[ADDR_WIDTH  :0]	wr_addr_gray;			//写地址格雷码
	logic 	[ADDR_WIDTH  :0]	rd_addr_gray;			//读地址格雷码

	logic  	[ADDR_WIDTH  :0]	wr_addr_gray_d1;		//消除亚稳态一级寄存器
	logic  	[ADDR_WIDTH  :0]	wr_addr_gray_d2;		//消除亚稳态二级寄存器
	logic  	[ADDR_WIDTH  :0]	rd_addr_gray_d1;		//消除亚稳态一级寄存器
	logic  	[ADDR_WIDTH  :0]	rd_addr_gray_d2;		//消除亚稳态二级寄存器	


	//==============================================================
	//寄存使能信号

	always_ff@(posedge wr_clk)begin
		wr_en_r 	<=	#1 wr_en;
	end

	always_ff@(posedge rd_clk)begin
		rd_en_r		<=	#1 rd_en;
	end


	//==============================================================
	//读写指针递增

	always_ff@(posedge wr_clk, negedge rst_n) begin
		if(!rst_n)
			wr_pointer <= #1 'h0;
		else if(wr_en_r && (~full))
			wr_pointer <= #1 wr_pointer + 1;
		else 
			wr_pointer <= #1 wr_pointer;
	end


	always_ff@(posedge rd_clk, negedge rst_n) begin
		if(!rst_n)
			rd_pointer <= #1 'h0;
		else if(rd_en_r && (~empty))
			rd_pointer <= #1 rd_pointer + 1;
		else 
			rd_pointer <= #1 rd_pointer;
	end


	//==============================================================
	//产生读写地址

	assign wr_addr = wr_pointer[ADDR_WIDTH-1:0];	//写地址为写指针去掉最高位
	assign rd_addr = rd_pointer[ADDR_WIDTH-1:0];	//读地址为读指针去掉最高位



	//==============================================================
	//读写
	
	always_ff@(posedge wr_clk) begin
		if(wr_en_r && (~full))
			fifo[wr_addr] <= #1 data_in;
	end


	always_ff@(posedge rd_clk) begin
		if(rd_en_r && (~empty))
			data_out <= #1 fifo[rd_addr];
	end


	//==============================================================
	//产生读写地址格雷码

	assign wr_addr_gray = (wr_pointer >> 1) ^ wr_pointer;	//产生写地址格雷码
	assign rd_addr_gray = (rd_pointer >> 1) ^ rd_pointer;	//产生读地址格雷码


	//==============================================================
	//寫指针格雷码同步化

	always_ff@(posedge rd_clk ) begin
		wr_addr_gray_d1 <= #1 wr_addr_gray;		//将写地址的格雷码转移到读时钟域，方便与读地址格雷码比较
		wr_addr_gray_d2 <= #1 wr_addr_gray_d1; 	//两级触发消除亚稳态                               
	end


	//==============================================================
	//读指针格雷码同步化

	always_ff@(posedge wr_clk) begin
		rd_addr_gray_d1 <= #1 rd_addr_gray;		//将读地址的格雷码转移到写时钟域，方便与写地址格雷码比较
		rd_addr_gray_d2 <= #1 rd_addr_gray_d1;	//两级触发消除亚稳态                               
	end


	//==============================================================
	//空满判断

	assign full = (wr_addr_gray == {~(rd_addr_gray_d2[ADDR_WIDTH-:2]),rd_addr_gray_d2[ADDR_WIDTH-2:0]});	//写地址格雷码与读地址同步后的格雷码的高两位不同 即为满
	assign empty = ( rd_addr_gray == wr_addr_gray_d2 );	

endmodule
```

----

### 4 任意奇数分频器

```verilog
//------------------------------------------------------------------------------
//
//Module Name:					Odd_Frequency_Divider.v
//Department:					Xidian University
//Function Description:	   		任意奇数分频器
//
//------------------------------------------------------------------------------
//
//Version 	Design		Coding		Simulata	  Review		Rel data
//V1.0		Verdvana	Verdvana	Verdvana		        	2020-2-22
//
//-----------------------------------------------------------------------------------

`timescale 1ns/1ns

module Odd_Frequency_Divider #(
    parameter   DIV_COEFF   = 3
)(
    input       clk,
    input       rst_n,

    input       en,
    output      clk_out
);

    //位宽计算函数
    function integer clogb2 (input integer depth);
    begin
        for (clogb2=0; depth>0; clogb2=clogb2+1) 
            depth = depth >>1;                          
    end
    endfunction

    reg [clogb2(DIV_COEFF)-1:0] cnt;

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            cnt <= #1 '0;
        else if(cnt >= DIV_COEFF-1)
            cnt <= #1 '0;
        else
            cnt <= cnt + 1;
    end

    logic clk_pos,clk_neg;

    always_ff@(posedge clk, negedge rst_n)begin
        if(!rst_n)
            clk_pos <= #1 '0;
        else if(cnt <= (DIV_COEFF-1)/2)
            clk_pos <= #1 '1;
        else
            clk_pos <= #1 '0;
    end

    always_ff@(negedge clk, negedge rst_n)begin
        if(!rst_n)
            clk_neg <= #1 '0;
        else if(cnt <= (DIV_COEFF-1)/2)
            clk_neg <= #1 '1;
        else
            clk_neg <= #1 '0;
    end

    assign clk_out = clk_pos & clk_neg;


endmodule
```

----
&#160; &#160; &#160; &#160; 告辞