---
layout: post
title:  "基于FPGA的SDRAM读写实验"
date:   2019-3-6 18:21:10 +0700
tags:
  - FPGA
---

-------
### 1 前言

&#160; &#160; &#160; &#160; FPGA内部的存储资源有限，所以需要SDRAM来存取大量高速数据，同时也可以解决跨时钟域数据存取问题。

* 开发环境：
	* Quartus Prime Standard 18.1
* 操作系统：
	* Windows 10 Pro 1903

-------
### 2 SDRAM简介

#### 2.1 SDRAM介绍

&#160; &#160; &#160; &#160; SDRAM：
* Synchronous（同步）：说明需要时钟信号；
* Dynamic（动态）：需要刷新防止数据丢失；
* Random（随机）：根据指定地址自由读写。

&#160; &#160; &#160; &#160; SDRAM内部是四个存储阵列（4个bank），每个bank就像一张表，有行地址和列地址。所以SDRAM的容量可以通过以下公式计算：

* SDRAM总存储容量 = 行数 × 列数 × BANK数量 × 每个存储单元的位数 （单位：bit）

&#160; &#160; &#160; &#160; 比如DE1-SoC上的SDRAM:IS42R16320D。行列和块地址如下表：

| 名称 | 宽度 | 地址 |
| ----- | ----- | ----- |
| 行地址 &#160; | 13 &#160; &#160; &#160; &#160; | A0-A12 |
| 列地址 &#160; | 10 &#160; &#160; &#160; &#160; | A0-A9 |
| 块地址 &#160; | 2 &#160; &#160; &#160; &#160; | BA0,BA1 |


&#160; &#160; &#160; &#160; 由公式可得：

* SDRAM总存储容量 = 2^13 × 2^10 × 2^2 × 16bit = 32M × 16bit = 512Mbit



&#160; &#160; &#160; &#160; SDRAM内部是四个存储阵列（4个bank），每个bank就像一张表，有行地址和列地址。
确定其中的某一个位置，需要先选中bank地址（BANK ADDR），再选中行地址（ROW ADDR），最后选中（COLUMN ADDR）。

&#160; &#160; &#160; &#160; 查看数据手册可得知SDRAM工作时钟频率。还以IS42R16320D为例：

> Clock frequency: 200, 166, 143 MHz

&#160; &#160; &#160; &#160; 所以它可以在以上三种频率下工作。

#### 2.2 SDRAM命令介绍

&#160; &#160; &#160; &#160; 要控制SDRAM需要给它写命令，SDRAM有三个命令控制引脚“RAS”、“CAS”和“WE”，对应内部有命令解码器，主控就是通过这三个接口通道来发送命令，然后解码器解码从而控制SDRAM。SDRAM的初始化、读写等操作其实就是给它命令，通过命令的配置告诉SDRAM以什么样的模式配置、工作方式和工作内容等等。下表为SDRAM基本操作命令：

| 命令 | 缩写 &#160;  &#160;  | RAS &#160;  &#160;  | CAS &#160;  &#160;  | WE &#160;  &#160;  |
| --- | --- | --- | --- | --- |
| 空操作 | NOP | 1 | 1 | 1 |
| 读操作 | ACT | 0 | 1 | 1 |
| 写操作 | RD | 1 | 0 | 1 |
| 突然操作终止 | BT | 1 | 1 | 0 |
| 预充电 | PALL | 0 | 1 | 0 |
| 刷新操作 | SELF | 0 | 0 | 1 |
| 配置模式寄存器 &#160;  &#160;  | MRS | 0 | 0 | 0 |



#### 2.3 模式寄存器

&#160; &#160; &#160; &#160; 除命令解码器之外，SDRAM内部还有个模式寄存器（Mode Register，MR）。在SDRAM上电初始化的过程中需要模式寄存器的设置。模式寄存器通过地址总线来设置，并且将会一直保存配置信息直到下一次编程或掉电为止。模式寄存器的地址总线定义如下表：

![3](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84SDRAM%E8%AF%BB%E5%86%99%E5%AE%9E%E9%AA%8C/3.jpg)


&#160; &#160; &#160; &#160; 其中，突发（Burst）是指在同一行中相邻的存储单元进行数据传输的方式，连续传输的周期数就是**突发长度**，只要指定起始列地址和突发长度，寻址与数据的读取将自动进行。



#### 2.4 SDRAM初始化时序

&#160; &#160; &#160; &#160; 正如之前说的，SDRAM的初始化主要是为了完成SDRAM的模式配置，初始化流程有严格的规定：

![1](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84SDRAM%E8%AF%BB%E5%86%99%E5%AE%9E%E9%AA%8C/1.jpg)

&#160; &#160; &#160; &#160; 其中上电初期100μs的等待时间必须给足，一般直接上200μs。

&#160; &#160; &#160; &#160; 由于SDRAM的L-Bank逻辑单元是电容结构，容易掉点，所以要及时充电。手册规定必须每64ms对所有行、列完成一次刷新，确保数据得更新，叫做**预刷新**。

#### 2.5 SDRAM读写操作

&#160; &#160; &#160; &#160; SDRAM常用两种读写操作方式：

* 通过地址索引实现单个逻辑单元数据的读写；
* 通过突发连续读写来实现最多256个数据的连续操作。

&#160; &#160; &#160; &#160; 为了实现更高的带宽，一般采用突发连续读写操作方式。SDRAM突发读写的时序如下图：

![2](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84SDRAM%E8%AF%BB%E5%86%99%E5%AE%9E%E9%AA%8C/2.jpg)

&#160; &#160; &#160; &#160; 前面说了突发读写，如果要连续的突发传输，只需要控制好两端突发读取命令的间隔周期即可。突发长度在模式寄存器的配置中初始化有1、2、4、8以及256个数据的操作模式。SDRAM突发长度寄存器配置表如下：

| M3 | M2 | M1 | M0 | 突发长度 |
| --- | --- | --- | --- | --- |
| 1/0 | 0 | 0 | 0 | 1 |
| 1/0 | 0 | 0 | 1 | 2 |
| 1/0 | 0 | 1 | 0 | 4 |
| 1/0 | 0 | 1 | 1 | 8 |
| 1/0 | 1 | 0 | 0 | Reserved |
| 1/0 | 1 | 0 | 1 | Reserved |
| 1/0 | 1 | 1 | 0 | Reserved |
| 0 | 1 | 1 | 1 | 全页 |
| 1 | 1 | 1 | 1 | Reserved |

&#160; &#160; &#160; &#160; 同时，突发读写实现的是连续的读写操作。在结束一次突发读写前，不需要重新进行行地址索引。但需要注意的是这条个连续读写操作的重点在于操作的连续，而非地址的连续。另外在模式寄存器配置中，可以设定SDRAM突发读写为顺序读写或交错读写。寄存器配置表如下：

| M3 | 突发模式 |
| --- | --- |
| 0 | Sequential |
| 1 | Interleaved |

&#160; &#160; &#160; &#160; 在大量数据流的缓存处理中，设置为顺序式的突发读写模式，同时以全页读写的方式进行突发读写操作，能达到更大的带宽，更高的效率。但这样做的前提是每次读取或写入时，都必须准备好256个数据缓存器，以保证数据的读写能够连续进行，因此还需要用到FIFO。

----

### 3 SDRAM控制器HDL设计

#### 3.1 宏定义

&#160; &#160; &#160; &#160; 为了方便移植与修改，先将SDRAM控制器代码中用到的参数进行宏定义。

&#160; &#160; &#160; &#160; 首先是行地址列地址和BANK地址。根据数据手册可以看出，





--------

&#160; &#160; &#160; &#160; 告辞。

