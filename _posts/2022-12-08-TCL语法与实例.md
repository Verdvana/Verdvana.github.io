---
layout: post
title:  "Tcl语法与实例"
date:   2022-12-08 20:27:10 +0700
tags:
  - Tcl
---

-------


## 1 前言

&#160; &#160; &#160; &#160; 搞IC的哪能不会Tcl，虽然我也是才学😅。


----

## 2 Tcl基础

### 2.1 简介

&#160; &#160; &#160; &#160; Tcl全称Tool command language，是一种解释性语言，不像其他高级语言需要编译，而像shell语言一样，直接对每条语言顺次解释执行。对它而言，要处理的数据只有一种——字符串，它将变量值以字符串的形式进行存储，不关心它的实际使用类型。

&#160; &#160; &#160; &#160; Tcl的执行是交互式的，Tcl提供了交互式命令界面：tclsh和wish。tclsh只支持Tcl命令，wish支持Tcl和Tk命令。通过交互界面，我们就可以像执行shell命令一样，逐条命令执行，并即时得到执行结果。

### 2.2 命令格式

&#160; &#160; &#160; &#160; 一条Tcl基本语法为：

```tcl
#命令 参数1 参数2 ...
command arg1 arg2 ... 
```

&#160; &#160; &#160; &#160; 其中command为Tcl内建命令或者Tcl过程，各条命令可以单独一行，**也可以在同一行，在同一行时，要用“;”来分割：**

```tcl
command1 arg1; command2 arg2; #comment
```


&#160; &#160; &#160; &#160; 字符串中如果有空格，要用“”或者{}括起来，因为Tcl语句中各命令参数是以空格来分割的，否则，字符串中的单词会被认为多余的参数而出错。

### 2.3 可执行脚本文件

&#160; &#160; &#160; &#160; 编写完一个脚本文件吼，可用source来执行该脚本，但需要先启动tclsh。要编写可执行脚本文件，需要在脚本中加入指定解释器，类似其他脚本比如Perl：
```tcl
#!/usr/bin/tclsh
```


----

## 3 输出、复制与替换

### 3.1 puts

&#160; &#160; &#160; &#160; Tcl的输出命令是“puts”，将字符串输出到标准输出channelld：

```tcl
puts hello;                   # 字符串不需要引号
puts "hello world";           # 有空格需要加引号或花括号
puts -nonewline "hello world";# 此选项不输出回车换行
```

&#160; &#160; &#160; &#160; 需要注意的是，**双引号和花括号是有差别的，在处理“替换操作时”，前者允许替换发生，后者可能会阻止替换。**

### 3.2 set&unset

&#160; &#160; &#160; &#160; set为变量定义和赋值命令，不需要指定变量值的类型，因为**变量值的类型只有一种：字符串。**

&#160; &#160; &#160; &#160; unset命令与set命令作用相反，它取消变量定义，并释放变量所占的内存空间。

&#160; &#160; &#160; &#160; 通过“$”符，可以引用变量的值。

&#160; &#160; &#160; &#160; set命令也可以只跟变量而无变量值，若变量已经定义，则返回变量值，效果和puts类似。如果变量不存在，则返回错误信息。

```tcl
set   a hello;                # 定义变量a并赋值字符串
set   a "hello world";        # 重新赋值
set   a;                      # 输出变量a值，此时不加“$”
puts  $a;                     # 输出变量a值，此时要加“$”
set   b $a;                   # 将变量a的值赋给b
unset a;                      # 释放变量a
puts  $a;                     # 报错“can't read "a": no such variable”
```

### 3.2 替换

&#160; &#160; &#160; &#160; “$”可以实现替换，例如3.1节中提到的。Tcl对替换只进行一次解释，对嵌套的“$”不予理睬。

```tcl
set a x;                      # 定义变量a为x
set b a;                      # 定义变量b为a
puts $$b;                     # 等效为 puts {$a}
```

&#160; &#160; &#160; &#160; 方括号“[]”完成命令替换，将命令括起来，命令执行完后，返回结果。

```tcl
set b [set a 5];              # 将set a 5的结果赋值给b，即set b 5
set c [expr 5*10];            # 将乘式结果赋给c
```

&#160; &#160; &#160; &#160; 双引号和花括号黄多个单词组成一个参数，也是一种替换操作。双引号可以正常替换，花括号会组织内部的嵌套替换，如puts {$a}；如果花括号用作界定符，如过程定义时用作界限过程体时，不阻止替换操作，其他还有if条件语句、循环语句、switch语句和过程声明、数学表达式等。

```tcl
set s hello
puts "the length of \"$s\" is [string length $s]";  # 打印：the length of "hello" is 5
puts {the length of $s is [string length $s]};      # 打印：the length of $s is [string length $s]

set x 10;
set y 20;
set z [expr {$x+$y}];         # 用花括号来组织算术表达式，不阻止$替换操作
if {$x==10} {puts "x=$x"};    # 在条件语句中，花括号用来界定条件体喝执行体，不阻止内部替换
```


&#160; &#160; &#160; &#160; 反斜杠用来引用特殊字符，跟其他语言里类似。

----

## 4 数学表达式

### 4.1 数学和逻辑运算符

| 运算符 | 说明 |
| --- | --- |
| \- \+ \~ \! | 一元减（取负）、一元加、比特反、逻辑非 |
| \* / % | 乘、除、取余 |
| + - | 加、减 |
| << >> | 左移、右移 |
| < <= > >= | 布尔小于、小于或等于、大于、大于或等于 |
| == != | 布尔等、不等 |
| & | 比特与 |
| ^ | 比特异或 |
| \| | 比特或 |
| && | 逻辑与 |
| \|\|| 逻辑或 |
| x?y:z | 三目运算符，跟verilog里一样 |

### 4.2 数学函数

| 函数名 | 说明 | 举例 |
| --- | --- | --- |
| abs() | 绝对值 |  |
| acos() | 反余弦 |  |
| asin() | 反正弦 |  |
| atan() | 反正切 |  |
| atan2 | 比值取反正切 |  |
| ceil() | 返回不小于输入值的整数值 |  |
| cos() | 余弦 |  |
| cosh() | 双曲余弦 |  |
| double() | 转换双精度 |  |
| exp() | e的幂 |  |
| floor() |  |  |
| fmod | 取余（结果为浮点型） |  |
| hypot(x,y) | 根据直角三角形两直角边长度计算出斜边长度 |  |
| int() | 取整 |  |
| log() | 自然对数 |  |
| log10() | 以十为底的对数 |  |
| pow | 幂运算 |  |
| rand() | 取0到1之间的随机实数 |  |
| round() | 四舍五入取整 |  |
| sin() |  |  |
| sinh |  |  |
| sqrt() | 求二次根 |  |
| srand() | 以输入的整数为随机数生成器的种子产生随机数 |  |
| tan() |  |  |
| tanh() |  |  |


### 4.3 incr命令

&#160; &#160; &#160; &#160; incr命令根据指定的步长来增加或减少参数的值，默认步长为+1。

```tcl
set a 5;        # a=5
incr a;         # a=6
incr a -2;      # a=4
```

----

## 5 字符串

### 5.1 基本命令

| 命令 | 描述 |
| --- | --- |
| append | 将值追加到字符串尾 |
| binary | 二进制字符串操作 |
| format | 字符串格式化 |
| regexp | 正则表达式 |
| regsub | 用正则表达式进行字符串模式匹配和替换 |
| scan | 字符串分解 |
| string *option* | 字符串操作和命令集 |
| subst | 字符代替（替代特殊字符） |

### 5.2 append

&#160; &#160; &#160; &#160; 将字符串连接到零一字符串尾部，组成新的字符串。此命令对变量直接修改。

```tcl
set var1 hello
set var2 world

append var1 $var2;      # $var1的内容为“helloworld”
```

### 5.3 format

&#160; &#160; &#160; &#160; 和C语言中的printf命令类似，它根据一组格式说明来格式化字符串。他不会改变被操作字符串的内容。

```tcl
format spec val1 val2
```



### 5.4 scan

&#160; &#160; &#160; &#160; scan命令根据格式描述符来解析一个字符串并将对应值赋值给后面的变量，返回成功转换的个数。

### 5.5 binary

&#160; &#160; &#160; &#160; Tcl8.0之后增加了对二进制字符串的支持。

&#160; &#160; &#160; &#160; 根据数据的存储组织形式，可以分为ASCII形式和二进制形式。按ASCII存放时，每个字节存放一个ASCII代码，代表一个数字字符，以二进制存放的时候，将存储数字的二进制值。



### 5.6 subst

&#160; &#160; &#160; &#160; subst命令在字符串中搜索方括号、美元符号和反斜杠，并对其进行替换操作，而对其他数据不做处理，字符串内部的花括号对这种替换操作不阻止。

```tcl
subst {a = $a sum=[expr 1+2]};      # 
subst {a = {$a} sum={[expr 1+2]}};  # 
```

### 5.7 string

&#160; &#160; &#160; &#160; string命令提供了一些简单的模式匹配机制，而正则表达式则提供了更为复杂、更为强大的模式匹配机制。

#### 5.7.1 string命令列表

&#160; &#160; &#160; &#160; 下表给出了string命令语法格式和说明。

| 命令 | 说明 |
| --- | --- |
| string bytelength  str1 | 返回用于存储字符串的字节数 |
| string compare [-nocase] [-length len] str1 str2  | 根据字典顺序比较字符串。-nocase选项表示大小写无关。-length选项表示只比较指定长度的开头部分字符。如果字符串相同就返回0；如果str1的顺序比str2考前就返回-1，其他情况返回1 |
| string equal [-nocase] str1 str2 | 比较字符串，相同返回1，否则返回0 |
| string first str1 str2 | 返回在str2中str1第一次出现的索引位置，如果没有找到则返回-1 |
| string index str1 var1 | 返回指定位置的字符，var1是从0开始 |
| string is class [-strict] [-failindex varname] str1 | 判断字符串类型，如果是指定类型就返回1，有整形，布尔型等。-strict表示不匹配空字符；如果指定了failindex则将string中非class的字符索引赋给varname变量 |
| string last str1 str2 | 返回str2在str1最后一次出现的位置索引，没有索引就返回-1 |
| string length str1 | 返回str1中的字符个数 |
| string map [-nocase] chaMap str1 | 返回根据charMap中输入、输出列表，将str中的字符进行字符映射后而产生的新字符串 |
| string match pattern str1 | 如果str1匹配pattern就返回1，否则返回0；使用的是通配风格的匹配 |
| string range str1 index1 index2 | 返回str1中从index1到index2之间的字符串 |
| string repeat str1 count | 返回将str1重复count次的字符串 |
| string replace str1 first last [newstr] | 将从first开始到last结束的一段字符串替换为newstr字符串，如果newstr没有，则这部分字符串内推将被删除 |
| string tolower str1 [first] [last] | 将制定范围的字符串转化为小写格式 |
| string totile str1 [first] [last] | 通过将第一个字符替换为Unicode的标题型字符或大写形式，而其余的替换为小写形式的方法，将str1转换为开始字母大写形式，可以从参数指定操作范围 |
| string toupper str1 [first] [last] | 将指定范围的字符转化为大写形式 |
| string trim str1 [chars] | 从str1两端删除chars中指定的字符，chars默认为空字符 |
| string trimleft str1 [chars] | 从str1开头删除chars中指定的字符，chars默认为空字符 |
| string trimright str1 [chars] | 从str1结尾删除chars中指定的字符，chars默认为空字符 |
| string wordend str1 index | 返回str1中在索引位置index包含字符的单词之后的字符的索引位置 |
| string wordstrat str1 index | 返回str1中在索引位置index包含字符的单词中第一个字符的索引位置 |

#### 5.7.2 字符串比较

&#160; &#160; &#160; &#160; 如果用比较运算符“==”、“!”、“<”、“>”，**必须用双引号来将字符串值括起来**，这样表达式语法分析器才能按照字符串类型来进行识别，然后**必须用花括号将整个表达式括起来以阻止主解释器将双引号去掉**。

```tcl
if {$x=="ture"} {puts OK}
```

&#160; &#160; &#160; &#160; 然而这样的直接比较还是会带来一些意想不到的问题，比较安全的方法是使用string中的两个比较命令来操作，**执行速度也更快**。

```tcl
set s1 abc
set s2 abd

if {[string compare $s1 $s2]==0} {
  puts "s1 is same as s2"
} else {
  puts "s1 isn't same as s2"      ;# 打印此信息
}

if {[string equal $1 $2]} {
  puts "s1 is same as s2"
} else {
  puts "s1 isn't same as s2"      ;# 打印此信息
}
```

&#160; &#160; &#160; &#160; 注意命令返回值，compare在不同的情况下返回1，而equal在相等时返回1。

#### 5.7.3 字符串匹配

&#160; &#160; &#160; &#160; string match沿用了各类UNIX shell中所使用的文件名模式匹配机制，下表给出了匹配模式的三种结构：

| 字符 | 说明 |
| --- | --- |
| \* | 通配符 |
| \? | 匹配一个字符 |
| [chars] | 匹配chars中的任意一个字符 |

&#160; &#160; &#160; &#160; 为了使结果返回1（匹配），pattern和字符str必须相同，除非使用了匹配字符。

```tcl
string match a* alpha               ;# 返回1
string match ? XY                   ;# 返回0
string match ?? XY                  ;# 返回1，一个“?”对应一个字符

string match {[ab]*} bell           ;# 返回1
string match {[a-z0-7]} 7           ;# 返回1
string match {[a-c][o-q]?} "apo"    ;# 返回1

string match {*\?} "who are u?"     ;# 返回1
string match *\a "who are u?"       ;# 返回0，“\a”被进行了替换
string match *\\a "who are u?"      ;# 返回1

set pat {[ab]*x}
string match $pat box               ;# 返回1

```

#### 5.7.4 字符串替换

&#160; &#160; &#160; &#160; string replace可以用新的字符串代替字符串中指定范围内的字符，如果没有指定新字符串，则指定范围内的字符串都会被删除，替换不改变原来字符串变量的值，只是返回更改后的新字符串。

```tcl
string replace aaaabbbb 1 3 ccc     ;# acccbbbb
string replace aaaabbbb 1 3         ;# abbbb

set a aaabbb
string replace $a 1 2               ;# abbb
```

----
&#160; &#160; &#160; &#160; 告辞。

