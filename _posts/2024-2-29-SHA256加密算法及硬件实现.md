---
layout: post
title:  "SHA256加密算法的硬件实现"
date:   2024-2-29 9:37:10 +0700
tags:
  - Hardware Algorithm
  - Verilog HDL
---

-------

## 1 前言

&#160; &#160; &#160; &#160; 网上讲SHA256算法的文章很多，大多数都是从算法角度或软件角度分析的。所以我们从硬件角度分析和设计一下SHA256算法。

* 哈希标准文档：
  * [Secure Hash Standard (SHS)](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)


### 1.1 SHA概述

&#160; &#160; &#160; &#160; 由文档可知，SHA256算法分为以下几步：

* 预处理
  * 填充比特
  * 填充长度值
* 哈希计算

### 1.2 常数

&#160; &#160; &#160; &#160; 由文档可知，SHA256要用到以下8个1字节（32bit）的初始哈希值$H_0^{(0)}$~$H_7^{(0)}$：

```
6a09e667 bb67ae85 3c6ef372 a54ff53a
510e527f 9b05688c 1f83d9ab 5be0cd19
```

&#160; &#160; &#160; &#160; 以及64个1字节（32bit）的常量$K_0^{(256)}$~$K_{63}^{(256)}$，它们是对自然数中前64个质数的立方根的小数部分的前32bit：

```
428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5
d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174
e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da
983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967
27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85
a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070
19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
```

### 1.3 函数

&#160; &#160; &#160; &#160; 由文档可知，SHA256要用到以下6个函数

$Ch(x,y,z) = (x \land y) \oplus (\lnot x \land z)$

$Ma(x,y,z) = (x \land y) \oplus (x \land z) \oplus (y \land z) $

$\sum_0(x) = S^2(x) \oplus S^{13}(x) \oplus S^{22}(x)$

$\sum_1(x) = S^6(x) \oplus S^{11}(x) \oplus S^{25}(x)$

$\sigma_0(x) = S^7(x) \oplus S^{18}(x) \oplus R^3(x)$

$\sigma_1(x) = S^{17}(x) \oplus S^{19}(x) \oplus R^{10}(x)$


&#160; &#160; &#160; &#160; 其中：

| 逻辑运算 | 含义 |
| --- | --- |
| $\land$ | 按位与 |
| $\lnot$ | 按位补 |
| $\oplus$ | 异或 |
| $S^n$ | 循环右移n位 |
| $R^n$ | 逻辑右移n位 |


&#160; &#160; &#160; &#160; 因此，转换成HDL伪代码：
```verilog
Ch(x,y,z) = (x & y) ^ (~x & z);
Ma(x,y,z) = (x & y) ^ (x  & z) ^ (y & z);
sum_0(x)  = {x[1:0],x[31:2]}   ^ {x[12:0],x[31:13]} ^ {x[21:0],x[31:22]};
sum_1(x)  = {x[5:0],x[31:6]}   ^ {x[10:0],x[31:11]} ^ {x[24:0],x[31:25]};
sigma_0(x)= {x[6:0],x[31:7]}   ^ {x[17:0],x[31:18]} ^ x>>3;
sigma_1(x)= {x[16:0],x[31:17]} ^ {x[18:0],x[31:19]} ^ x>>10;
```



----

## 2 预处理

### 2.1 算法分析

&#160; &#160; &#160; &#160; 


```wavedrom
{ signal: [
  { name: "clk",      wave: "p....|................" },
  { name: "wr_en",       wave: "01...|.0.............." },
  { name: "din",      wave: "x34x.|5==.|.67x.|89x..", data:"D0 D1 D99 128 00 A0 A1 A6 A7"},

  { name: "msg_wr", wave: "0.1..|..............0." },
  { name: "msg_din",  wave: "xx34x|.5==|..67x|.89x.", data:"D0 D1 D99 128 00 A0 A1 A6 A7" },
  { name: "cnt_bit",  wave: "=..=x|.==x|.===x|.====", data:"0 8 792 800 952 960 968 1008 1016 1024 0" },
  { name: "curr_stat", wave: "x.3..|..45|..6..|...7x", data:"COPY P1 P0 PA DONE" },
  { name: "next_stat", wave: "x3...|.45.|.6...|..7x.", data:"COPY P1 P0 PA DONE" },

]}
```
----

[img1]: