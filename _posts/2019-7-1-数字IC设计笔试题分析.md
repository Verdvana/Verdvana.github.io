---
layout: post
title:  "数字IC设计笔试题分析"
date:   2019-7-1 15:00:10 +0700
tags:
  - Digital IC Design
---

-------
### 1 FIFO设计

#### 1.1 如何设计合理的FIFO宽度和深度

* 异步FIFO的要点：
  * 读写指针采用格雷码，消除亚稳态；
  * 空满标志的生成方法。

&#160; &#160; &#160; &#160; 异步FIFO的一个重要属性是它的深度，即FIFO最多可以存储的以位为单位的数据的个数，他决定了数据传输的延时和吞吐量，是影响系统性能的一个重要参数。

&#160; &#160; &#160; &#160; 给系统中的异步FIFO设定适当的深度，既可以满足系统的性能需求，又可以优化系统的面积和功耗，因此受到人们的关注。

&#160; &#160; &#160; &#160; 这样就需要一种通过分析异步FIFO动态参数，来确定其深度的方法。异步FIFO的动态参数包括FIFO的饱和度、读写速率和溢出情况等，它们反映了FIFO的运行状况并且对确定FIFO的深度有指导意义。设计者可以根据这些动态参数，分析FIFO深度对系统性能的影响，为异步FIFO确定适当的深度。

* 饱和度
  * 某一时刻FIFO中已存储数据的个数相对于FIFO深度的百分比；
  * FIFO的饱和度是瞬时值，反映了当前FIFO中存储单元的使用率；
  * 其值为0表示FIFO中没有数据，值为100表示FIFO已满，存储单元的使用达到饱和；
  * 在FIFO运行过程当中，如果其饱和度一直很低，则表明FIFO的深度值过大，很多存储单元被浪费了；如果频繁出现饱和状态，则表明FIFO的深度值过小，存储单元使用紧张。
* 写入端和读出端的传输速率
  * 单位时间内向FIFO中写入数据的字节数和从FIFO中读出数据的字节数。
* 上溢频率和下溢频率
  * 当FIFO已满时，若发送端仍然向FIFO中写入数据，则FIFO发生上溢；反之，当FIFO为空时，接收端从FIFO中读出数据，则发生下溢。
 
&#160; &#160; &#160; &#160; 假设在FIFO的写入端执行32个字节的burst写操作，相邻两次burst操作的时间间隔服从**泊松分布**。 

&#160; &#160; &#160; &#160; FIFO之后的处理模块将FIFO中的数据读出，并通过总线存储到SRAM中供总线上其他模块处理。处理模块的的占用率由总线仲裁器控制控制，采用**分时复用**策略。

&#160; &#160; &#160; &#160; 深度太低时，容易发生写操作丢失；深度太高时，写入速率变化与深度正常时的写入速率变化完全一致，表面FIFO深度足够大时，其对写入速度就没有影响了。

> 例题：
> 
> &#160; &#160; &#160; &#160; 假设FIFO的写时钟为100MHz，读时钟为80Mhz。在FIFO输入侧，每100个写时钟，写入80个数据；读数据侧，假定每个时钟读走一个数据。请问FIFO的深度设置多少可以保证FIFO不会上溢出和下溢出？
> 
> 解：
>  
> &#160; &#160; &#160; &#160; 假设写入时为最坏情况（背靠背），即在160×(1/100)微秒内写入160个数据。以下是写入160个burst数据的时间计算方法：
> ```t
> Time:burst_cycle × Twclk = (burst_cycle) / (Fwclk) = 160 / 100
> ```
> &#160; &#160; &#160; &#160; 在这段时间内只能读出160×(1/100)×80个数据：
> ```t
> data_num = Time / Tr = Time × Fr = 160/100 × 80
> ```
> &#160; &#160; &#160; &#160; 因此该FIFO的深度为：
> ```t
> depth = burst - data_num = 160 - 160/100 × 80 = 32
> ```

&#160; &#160; &#160; &#160; 将问题一般化：

* 写时钟频率：WCLK;
* 读时钟频率：RCLK;
* 写时每B个时钟周期内会有A个数据写入FIFO；
* 读时每Y个时钟周期内会有X个数据读出FIFO；

&#160; &#160; &#160; &#160; 则FIFO的最小深度是多少？

```t
depth = burst_length - (burst_length/WCLK) × (RCLK × (X/Y))
```
* (burst_length/WCLK)表示这个burst的持续时间，(RCLK × (X/Y))表示读的实际速度，两者的乘积自然就是这段时间读出的数据量；
* burst_length表示这段时间写入的数据量；
* 写入和读出两者之差为FIFO中残留的数据，这个也就是理论上FIFO的最小深度。

-------

#### 1.2 如何在2次幂和非2次幂深度下设计相应的读写指针

&#160; &#160; &#160; &#160; 为什么需要格雷码做读写指针？

&#160; &#160; &#160; &#160; 由于异步FIFO是工作在两个不同的时钟域中，如果读写地址在某一时刻从0111到1000转变，恰好写时钟要在这时刻采样读地址，那么得到的只有可能是0000至1111中的任一个值。这个不确定的读地址会导致空满状态判断错误，这就是亚稳态。

&#160; &#160; &#160; &#160; 亚稳态的出现是不可避免的，如果把二进制地址计数器转换成格雷码然后再采样，而不是直接采样二进制计数器出来的值，那么就能很好的减少亚稳态的发生。

&#160; &#160; &#160; &#160; 引用格雷码后，相邻数值只有1位发生翻转，1位翻转所引起的亚稳态的概率远远小于几位同时翻转所引起的概率。因此，格雷码能很好的降低亚稳态出现的概率。


 | 数值 | 格雷码 |
 | --- | --- |
 | 0 | 000 |
 | 1 | 001 |
 | 2 | 011 |
 | 3 | 010 |
 | 4 | 110 |
 | 5 | 111 |
 | 6 | 101 |
 | 7 | 100 |

> 例：
>
> &#160; &#160; &#160; &#160; 假设FIFO深度为6，如果读写指针继续使用格雷码，那么当前首尾指针所有比特位都不相同。此时，如果从尾部返回首部，则无法实现消除亚稳态的目的。
> 
> &#160; &#160; &#160; &#160; 解决办法：可将地址为5的指针设定为100，此时其与首地址“000”相差一个bit位。与地址为4的指针“110”也相差一个bit位，满足消除亚稳态要求。

* 并不是一定要用格雷码做读写指针，而是当前深度为2次幂的时候，刚好格雷码满足消除亚稳态的需求；
* 在非2次幂深度情况下，格雷码不再适用，此时的解决方法通常有：
    * 若深度为偶数，可采用最接近的2次幂的格雷码编码，在此基础上修改；
    * 深度为一般数值是，可自行设计一种逻辑电路或查找表，以实现指针每次只跳变一次的功能；
    * 以上方法通常在设计层面较为复杂，若无特定需求，可将FIFO深度设置为2次幂，浪费一些存储空间，来简化控制电路的复杂度。

-------
#### 1.3 FIFO中亚稳态的消除


&#160; &#160; &#160; &#160; 亚稳态不能从根本上消除，但可以采取一定的措施使其对电路造成的影响降低。通常我们用故障间隔平均时间（MTBF,mean time between failures）来衡量亚稳态的影响。**MTBF越大则说明亚稳态对电路产生的影响越小，反之亦然。**
如当MTBF等于几十年或上百年时，我们就认为它对电路的影响基本上可以忽略。实验结果表明：对于输入为异步信号的电路，其MTBF与从亚稳态状态下恢复的时间长度有着指数的关系：
```t
MTBF = ( e^(Tmet/C2) ) / (C1 × Fclk × Fdata)
```
* Tmet： 寄存器从时钟上升沿触发后的时序余量时间；
* Fclk： 接收时钟域的时钟频率；
* Fdata：数据的变化频率
* C1/C2：与器件有关的参数，对于用户来说是固定值。

&#160; &#160; &#160; &#160; 格雷码一次只有一位数据发生变化，这样在进行地址同步的时候，只有两种情况：地址同步正确和地址同步出错但只有一位出错。第一种正确情况不需要分析，关注一下第二种。假设写地址从000变为001，读时钟域同步出错，写地址为000到000，也就是没有跳变，但是用这个错误的写地址去做空判断不会出错，最多是让空标志在FIFO不是真正空的时候产生，而不会出现空读的情形。

&#160; &#160; &#160; &#160; 所以格雷码保证的是同步后的读写地址即使再出错的情况下依然能够保持FIFO功能的正确性，当然同步后的读写地址出错总是存在的。

&#160; &#160; &#160; &#160; 这里需要注意的是格雷码只在相邻两次跳变之间才会出现只有1位数据不一致的情况，超过两个周期则不一定，所有地址总线bus skew一定不能超过一个周期，否则可能出现格雷码多位数据跳变的情况，这个时候格雷码就失去了作用，因为这时候同步后的地质已经不能保证只有1位跳变了。

-------

#### 1.4 两拍同步或多拍同步的差异

&#160; &#160; &#160; &#160; 将地址总线打两拍，这是为了避免亚稳态传播，理论上将打两拍不能消除亚稳态现象，因为时钟异步，亚稳态不可避免，但是可以极大降低亚稳态传播的概率，低频情况下甚至STA不需要分析这里的异步时序，因为寄存器都可以在一拍内将亚稳态消除，恢复到正常的0/1态。而在高频情况下则不一定，尤其是在28nm工艺以下，需要检查两级触发器的延迟，保证延迟低，这样可以提高Tr，提高系统MTBF。

&#160; &#160; &#160; &#160; 多拍能够将亚稳态出现的概率进一步降低。

-------
### 2 异步电路设计

#### 2.1 复位电路的亚稳态

![1](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/1.jpg)

&#160; &#160; &#160; &#160; 如果异步复位信号的撤销时间在Trecovery（恢复时间）和Tremoval（移出时间）之内，那势必造成亚稳态的产生，输出在时钟边沿的Tco后会产生振荡，振荡时间为Tmet（决断时间），最终稳定到“0”或“1”，就会可能造成复位失败。

&#160; &#160; &#160; &#160; 这也就是为什么采用“异步复位，同步释放”的原因。

#### 2.2 双锁存器法的优缺点和适用条件

&#160; &#160; &#160; &#160; 针对一个固定的设计，其他参数一般都是不可更改的，而能改变的只有Tdata。而这个Tdata是指两个寄存器之间的逻辑延时以及走线延时之和，要最大程度的减小它，只能是不在两个寄存器间添加任何逻辑而已，即为双锁存器法，这就是双锁存器可以降低亚稳态出现概率原理。

> 例：如果在两级同步器中插入若干buffer（不违反建立时间），对亚稳态的解决有好的影响还是坏的影响？
> 


&#160; &#160; &#160; &#160; 双锁存器同步法如图：

![2](https://raw.githubusercontent.com/Verdvana/Verdvana.github.io/master/_posts/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/2.jpg)

* 优点 
    * 结构简单易于实现；
* 缺点
    * 增加了两级触发器延时；
    * 当快时钟域转到慢时钟域时，易造成慢时钟域采样丢失（还没来得及采用，数据就变化了）。

&#160; &#160; &#160; &#160; 故常用于**慢时钟域转到快时钟域**。

* 适用条件：
    * 慢时钟的周期>(快时钟的周期+路径延迟)，确保信号可以被快时钟采样到；
    * 数据变化间隔>(慢时钟周期+2×快时钟周期+路径延时)，确保所有的数据变化均能采集到。

&#160; &#160; &#160; &#160; 对于典型的0.25μm工艺ASIC库中的一个触发器，MTBF=2.01（day），即触发器每两天可能出现一次亚稳态。如果将采样时间f和异步事件触发频率α都提高，亚稳态出现还要频繁。对于同样的参数，双锁存器法可将MTBF提升为9.57*10^9年，这个数值足够保证电子系统稳定运行。

&#160; &#160; &#160; &#160; 三级或者更多级虽然能将亚万台出现的概率降得更低，但影响电路效率，通常用于服务器芯片。




----------

#### 2.3 采样中“快到慢”与“慢到快”

* 慢时钟到快时钟

    * 采用双锁存器法和边沿检测同步器。这种方法通常应用在慢速向快速时钟传递过程中，可以检测输入信号的上升沿，也可以检测它的下降沿；

    * 输入数据的宽度必须必一个接收时钟加上一个同步触发的hold时间要长，最安全的就是两个同步周期宽度。

* 快时钟到慢时钟

    * 采用脉冲检测同步器
        * 脉冲同步器的基本功能是从某个时钟域取出一个单时钟宽度脉冲，然后在新的时钟域建立另一个单时钟宽度的脉冲；
        * 输入脉冲之间的最小间隔必须等于两个同步器时钟周期。如果输入脉冲相互过近，则新时钟域中的输出脉冲也紧密相邻，结果是输出脉冲宽度比一个时钟周期宽。当输入脉冲时钟周期大于两个同步器时钟周期时，这个问题更严重。这种情况下，如果输入脉冲相邻太近，则同步器就不能检测到每个脉冲。
    
    * 结绳法1
        * 利用数据的边沿做时钟（上升沿）。可以将脉冲无限延长，直到可以采集到数据，然后复位，要考虑产生数据的频率；
        * 这种结绳法的原理是，数据作为Din_clkA，即当数据有上升沿时，寄存器1的输出将会稳定在高电平，此时等待clkB采样；当clkB完成采样后，寄存器4回输出高电平，若此时Din_clkA为低电平，那么即可完成复位，开始下一次采样等待；
        * 当数据来临时，clkB域需要等待3个clkB才会在寄存器4输出并完成输入端的复位，所以Din_clkA如果变化较快，即持续时间短于3个clkB，也就是Din_clkA频率大于clkB的1/3，那么这时Din_clkA的变化将无法被采样到，因为clkB域需要3个clkB才能完成采样，并且此时Din_clkA必须是低电平才能复位，采用异步复位；
        * 在慢时钟采样快时钟的时候，结绳法适合采样数据较少（即脉冲间隔较大）的控制信号。即脉冲间隔Ta>3Tb；即等待3个clkB时钟后，完成复位才允许下一个输入脉冲。
    
    * 结绳法2
        * 利用数据作为异步复位，置位信号。
    
    * 结绳法3
        * 利用握手协议。


------------------

#### 2.4 结绳法的适用条件、特点和分类

&#160; &#160; &#160; &#160; 结绳就是将单脉冲延长，以方便采集到数据。

* 结绳法分类
     * 利用脉冲的边沿做时钟；
     * 利用脉冲的电平（部分场合要求是最小脉冲宽度）做选择器或者异步复位，置位。

&#160; &#160; &#160; &#160; 另外的关键点就是什么时候结绳结束（采集到了数据就要让对方回到初始状态）。

* 操作方法
    * 利用采集到的脉冲做异步复位、置位；
    * 利用采集到的脉冲再次结绳采集做握手响应信号。


* 总结
    * 结绳法可以解决快时钟域向慢时钟域过渡的问题，且其适用的范围很广；
    * 但是结绳法实现较为复杂，特别是其效率不高，在对设计性能要求较高的场合应该慎用；
    * 慢到快只需要考虑亚稳态问题；
    * 快到慢除亚稳态问题外，还需要考虑慢时钟的采样速率问题，因为根据采样定理，采样频率低于信号最高频率2倍的时候，是无法完整采样的。




------------------

#### 2.5 多bit指示信号与数据流信号如何同步

* 多bit指示信号跨时钟域同步

 &#160; &#160; &#160; &#160; 以2bit指示信号传递给下一个时钟域，如果这两个信号存在一定偏差，后端的时钟域信号恰好采集在这个偏差上，这两个信号在下一个时钟域就会差一个周期。

 &#160; &#160; &#160; &#160; 所以解决这个问题的方法是只传递一个信号，然后在下一个时钟域里生成另外一个信号，就能保证时序不会改变。

* 多bit数据流跨时钟域传输

 &#160; &#160; &#160; &#160; 数据流和指示信号不同，数据流大多具有连续性，即背靠背传输；数据流要求信号具有较快的传输速度。

 &#160; &#160; &#160; &#160; 解决方法：使用FIFO。


----------

### 3 晶体管版图基础

#### 3.1 基本逻辑单元的版图

----

#### 3.2 CMOS器件结构

----

#### 3.3 CMOS工艺流程


